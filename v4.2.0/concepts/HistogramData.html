<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Transition to the HistogramData module</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '4.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="" href="../index.html" />
    <link rel="up" title="Concepts" href="index.html" />
    <link rel="next" title="How To Define Geometric Shape" href="HowToDefineGeometricShape.html" />
    <link rel="prev" title="Geometry of Shape" href="GeometryofShape.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="../_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>4.2</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://www.mantidproject.org">Home</a></li>
                <li><a href="http://download.mantidproject.org">Download</a></li>
                <li><a href="http://docs.mantidproject.org/nightly/">Documentation</a></li>
                <li><a href="http://www.mantidproject.org/Contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="transition-to-the-histogramdata-module">
<span id="histogramdata"></span><h1>Transition to the HistogramData module<a class="headerlink" href="#transition-to-the-histogramdata-module" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id4">Introduction</a><ul>
<li><a class="reference internal" href="#motivation" id="id5">Motivation</a></li>
<li><a class="reference internal" href="#concepts" id="id6">Concepts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-new-histogram-type" id="id7">The new <tt class="docutils literal"><span class="pre">Histogram</span></tt> type</a><ul>
<li><a class="reference internal" href="#id2" id="id8">Motivation</a></li>
<li><a class="reference internal" href="#overview" id="id9">Overview</a></li>
<li><a class="reference internal" href="#histogram" id="id10"><tt class="docutils literal"><span class="pre">Histogram</span></tt></a></li>
<li><a class="reference internal" href="#histogramx-histogramy-and-histograme" id="id11"><tt class="docutils literal"><span class="pre">HistogramX</span></tt>, <tt class="docutils literal"><span class="pre">HistogramY</span></tt>, and <tt class="docutils literal"><span class="pre">HistogramE</span></tt></a></li>
<li><a class="reference internal" href="#binedges" id="id12"><tt class="docutils literal"><span class="pre">BinEdges</span></tt></a></li>
<li><a class="reference internal" href="#points" id="id13"><tt class="docutils literal"><span class="pre">Points</span></tt></a></li>
<li><a class="reference internal" href="#counts" id="id14"><tt class="docutils literal"><span class="pre">Counts</span></tt></a></li>
<li><a class="reference internal" href="#frequencies" id="id15"><tt class="docutils literal"><span class="pre">Frequencies</span></tt></a></li>
<li><a class="reference internal" href="#countvariances-countstandarddeviations-frequencyvariances-and-frequencystandarddeviations" id="id16"><tt class="docutils literal"><span class="pre">CountVariances</span></tt>, <tt class="docutils literal"><span class="pre">CountStandardDeviations</span></tt>, <tt class="docutils literal"><span class="pre">FrequencyVariances</span></tt>, and <tt class="docutils literal"><span class="pre">FrequencyStandardDeviations</span></tt></a></li>
<li><a class="reference internal" href="#code-examples" id="id17">Code examples</a><ul>
<li><a class="reference internal" href="#working-with-bin-edges-and-counts" id="id18">Working with bin edges and counts</a></li>
<li><a class="reference internal" href="#working-with-points" id="id19">Working with points</a></li>
<li><a class="reference internal" href="#working-with-histograms" id="id20">Working with histograms</a></li>
<li><a class="reference internal" href="#working-with-the-new-matrixworkspace-interface" id="id21">Working with the new <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt> interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#legacy-interface" id="id22">Legacy interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rollout-status" id="id23">Rollout status</a></li>
<li><a class="reference internal" href="#dealing-with-problems" id="id24">Dealing with problems</a></li>
</ul>
</div>
<p>HistogramData is a new Mantid module dealing with histograms.
This is <strong>not</strong> a replacement for <tt class="docutils literal"><span class="pre">Histogram1D</span></tt> or <tt class="docutils literal"><span class="pre">ISpectrum</span></tt>, but rather deals with the <strong>histogram</strong> part of the data stored in those classes.
This document is intended for Mantid developers.
It informs about the transition to the new way of dealing with histograms, and explains the new interfaces.</p>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id4">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="motivation">
<h3><a class="toc-backref" href="#id5">Motivation</a><a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Make working with histograms <strong>easier</strong>.</li>
<li>Provide a <strong>safer</strong> way of working with histograms.</li>
<li>Details can be found in the <a class="reference external" href="https://github.com/mantidproject/documents/blob/master/Design/histogram_type.md">design document</a>.</li>
</ul>
</div>
<div class="section" id="concepts">
<h3><a class="toc-backref" href="#id6">Concepts</a><a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h3>
<div class="figure align-center" style="width: 50%">
<img alt="../_images/Histogram.png" src="../_images/Histogram.png" />
<p class="caption">The histogram concept and nomenclature in Mantid.
The expressions commonly used in Mantid to refer to these concepts are given in quotation marks.
Details can be found in the text below.
The CamelCase keywords are new types and will be introduced later.</p>
</div>
<p>Histogram data in Mantid is stored in a number of different ways that reflect the way it was produced, or the way algorithms deal with the data:</p>
<ul class="simple">
<li>The x-data (typically corresponding to TOF or units derived from TOF) can represent bin edges (1 more than y-values), or points (1 for each y-value).
Conversions between the two cases are done with the algorithms <tt class="docutils literal"><span class="pre">ConvertToPointData</span></tt> and <tt class="docutils literal"><span class="pre">ConvertToHistogram</span></tt>.</li>
<li>The y-data can be counts or counts divided by bin-width.
In the latter case a workspace is said to contain <em>distribution data</em>.
Conversions between the two cases are done with the algorithms <tt class="docutils literal"><span class="pre">ConvertToDistribution</span></tt> and <tt class="docutils literal"><span class="pre">ConvertFromDistribution</span></tt>.</li>
<li>The e-data (uncertainties) follows the same distinction as y-data.
It typically stores the standard-deviation, but is sometimes (internally and temporarily) converted to a variance, i.e., the square of the standard-deviation.</li>
</ul>
<p>The new histogram type described below is designed to follow the needs of the current way Mantid deals with histograms (the following description is mainly for x-data, but the same applies to y-data):</p>
<ol class="arabic simple">
<li>Some algorithms work with bin edges, some with points, and many do not care.</li>
<li>We need to share data, e.g., when the bin edges of all histograms in a workspace are identical. This is currently handled in <tt class="docutils literal"><span class="pre">ISpectrum</span></tt>, <tt class="docutils literal"><span class="pre">Histogram1D</span></tt>, and <tt class="docutils literal"><span class="pre">EventList</span></tt>, which store a copy-on-write pointer (<tt class="docutils literal"><span class="pre">Kernel::cow_ptr</span></tt>) to a <tt class="docutils literal"><span class="pre">std::vector&lt;double&gt;</span></tt>.</li>
</ol>
<p>Mantid developers are all familiar with these two facts:</p>
<ol class="arabic">
<li><p class="first">Algorithms that &#8220;do not care&#8221; access the data and simply work with it. All other algorithms attempt to determine whether the x-data corresponds bin edges or points by comparing its length to that of the y-data (or alternatively use <tt class="docutils literal"><span class="pre">MatrixWorkspace::isHistogramData()</span></tt>). Based on the result they may convert, e.g., bin edges to points.</p>
</li>
<li><p class="first">The copy-on-write mechanism is reflected in the interface of <tt class="docutils literal"><span class="pre">ISpectrum</span></tt> and <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt>:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">using</span> <span class="n">MantidVec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MantidVecPtr</span> <span class="o">=</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// Current ISpectrum interface:</span>
<span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="k">const</span> <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="k">const</span> <span class="n">MantidVecPtr</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="k">const</span> <span class="n">MantidVecPtr</span><span class="o">::</span><span class="n">ptr_type</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
<span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">dataX</span><span class="p">();</span>
<span class="k">const</span> <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">dataX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">readX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">MantidVecPtr</span> <span class="n">ptrX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// renamed to refX() in MatrixWorkspace</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Non-<tt class="docutils literal"><span class="pre">const</span></tt> access to data in a spectrum will trigger a copy.</li>
<li>To avoid triggering the copy we use <tt class="docutils literal"><span class="pre">readX()</span></tt>.</li>
<li>When we want to share data we use <tt class="docutils literal"><span class="pre">setX()</span></tt> with a <tt class="docutils literal"><span class="pre">shared_ptr</span></tt> or <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> (can be obtained with <tt class="docutils literal"><span class="pre">ptrX()</span></tt> or <tt class="docutils literal"><span class="pre">refX()</span></tt>).</li>
</ul>
</li>
</ol>
<p>The shortcomings of the current implementation are mostly obvious and can also be found in the <a class="reference external" href="https://github.com/mantidproject/documents/blob/master/Design/histogram_type.md">design document</a>.</p>
</div>
</div>
<div class="section" id="the-new-histogram-type">
<h2><a class="toc-backref" href="#id7">The new <tt class="docutils literal"><span class="pre">Histogram</span></tt> type</a><a class="headerlink" href="#the-new-histogram-type" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id8">Motivation</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>In its final form, we will be able to do things like the following (things not implemented yet are marked with an asterisk (*)):</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">BinEdges</span> <span class="n">edges</span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">};</span>
<span class="n">Counts</span> <span class="n">counts1</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">Counts</span> <span class="n">counts2</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="n">Histogram</span> <span class="n">histogram1</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">counts1</span><span class="p">);</span>
<span class="n">Histogram</span> <span class="n">histogram2</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">counts2</span><span class="p">);</span>
<span class="c1">// x-data in histogram1 and histogram2 is shared</span>

<span class="c1">// Uncertainties are auto-generated, unless specified explicitly</span>
<span class="k">auto</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">histogram1</span><span class="p">.</span><span class="n">countStandardDeviations</span><span class="p">();</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 2.0</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 10.0</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 2.0</span>

<span class="c1">// Arithmetics with histograms (*)</span>
<span class="n">histogram1</span> <span class="o">+=</span> <span class="n">histogram2</span><span class="p">;</span> <span class="c1">// Checks size, throws if mismatched!</span>
<span class="k">auto</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">histogram1</span><span class="p">.</span><span class="n">counts</span><span class="p">();</span>
<span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 4.0</span>
<span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 200.0</span>
<span class="n">counts</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 4.0</span>
<span class="c1">// Deals with errors as well!</span>
<span class="n">errors</span> <span class="o">=</span> <span class="n">histogram1</span><span class="p">.</span><span class="n">countStandardDeviations</span><span class="p">();</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 2.0</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// sqrt(200.0)</span>
<span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 2.0</span>

<span class="c1">// Need bin centers (point data) instead of bin edges?</span>
<span class="k">auto</span> <span class="n">points</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">points</span><span class="p">();</span>
<span class="c1">// Need variance instead of standard deviation?</span>
<span class="k">auto</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">countVariances</span><span class="p">();</span>
<span class="c1">// Need frequencies (distribution data) instead of counts?</span>
<span class="k">auto</span> <span class="n">frequencies</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">frequencies</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">frequencyVariances</span><span class="p">();</span>

<span class="c1">// Type-safe operations</span>
<span class="n">CountStandardDeviations</span> <span class="n">sigmas</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">};</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">setCountVariances</span><span class="p">(</span><span class="n">sigmas</span><span class="p">);</span> <span class="c1">// Ok, squares internally</span>
<span class="n">sigmas</span> <span class="o">+=</span> <span class="n">CountVariances</span><span class="p">{</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">};</span> <span class="c1">// Ok, takes sqrt before adding (*)</span>
<span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 0.2</span>
<span class="n">sigmas</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 0.2</span>
</pre></div>
</td></tr></table></div>
<p>Further planned features:</p>
<ul class="simple">
<li>Arithmetics will all sub-types (<tt class="docutils literal"><span class="pre">BinEdges</span></tt>, <tt class="docutils literal"><span class="pre">Points</span></tt>, <tt class="docutils literal"><span class="pre">Counts</span></tt>, and <tt class="docutils literal"><span class="pre">Frequencies</span></tt>, and also their respective <tt class="docutils literal"><span class="pre">Variances</span></tt> and <tt class="docutils literal"><span class="pre">StandardDeviations</span></tt>).</li>
<li>Generating bin edges (linear, logarithmic, ...).</li>
<li>Extend the <tt class="docutils literal"><span class="pre">Histogram</span></tt> interface with more common operations.</li>
<li>Non-member functions for more complex operations on histograms such as rebinning.</li>
<li>Validation of data, e.g., non-zero bin widths and positivity of uncertainties.</li>
</ul>
<p><strong>Any feedback on additional capabilities of the new data types is highly appreciated.
I will happily consider adding more features as long as they fit the overall design.
Please get in</strong> <a class="reference external" href="mailto:simon&#46;heybrock&#37;&#52;&#48;esss&#46;se">contact</a> <strong>with me!</strong></p>
<p>Basic changes have been merged (soon after the 3.7 release).
We will then work on reducing the use of the old interface (<tt class="docutils literal"><span class="pre">readX()</span></tt>, <tt class="docutils literal"><span class="pre">dataX()</span></tt>, <tt class="docutils literal"><span class="pre">readY()</span></tt>, ...) as much as possible.
After that, more features will follow.</p>
<p>We also want to expose most parts of the <tt class="docutils literal"><span class="pre">HistogramData</span></tt> module to Python, but no schedule has been decided yet.
Parts of the old interface will be kept alive for now, in particular to maintain support for the old Python interface.</p>
</div>
<div class="section" id="overview">
<h3><a class="toc-backref" href="#id9">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>A new module <tt class="docutils literal"><span class="pre">HistogramData</span></tt> has been added.</li>
<li><tt class="docutils literal"><span class="pre">Histogram1D</span></tt> and <tt class="docutils literal"><span class="pre">EventList</span></tt> now store their histogram data in the new type <tt class="docutils literal"><span class="pre">HistogramData::Histogram</span></tt>.</li>
<li>The public interface of <tt class="docutils literal"><span class="pre">ISpectrum</span></tt> and <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt> gives access to <tt class="docutils literal"><span class="pre">Histogram</span></tt> and its components, in a fashion similar to <tt class="docutils literal"><span class="pre">readX()</span></tt>, <tt class="docutils literal"><span class="pre">dataX()</span></tt>, etc.</li>
<li>The old <tt class="docutils literal"><span class="pre">readX()</span></tt>/<tt class="docutils literal"><span class="pre">dataX()</span></tt> interface is still available for the time being, but its use is unsafe (as before) and it should not be used anymore.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt> thus has a number of new public methods (details follow below):</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MatrixWorkspace</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Note return by value (see below)</span>
  <span class="n">Histogram</span> <span class="n">histogram</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setHistogram</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Note return by value (see below)</span>
  <span class="n">BinEdges</span> <span class="n">binEdges</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Points</span> <span class="n">points</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setBinEdges</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setPoints</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Note return by value (see below)</span>
  <span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">CountVariances</span> <span class="n">countVariances</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">CountStandardDeviations</span> <span class="n">countStandardDeviations</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Frequencies</span> <span class="n">frequencies</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">FrequencyVariances</span> <span class="n">frequencyVariances</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">FrequencyStandardDeviations</span> <span class="n">frequencyStandardDeviations</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCounts</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCountVariances</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCountStandardDeviations</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencies</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencyVariances</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencyStandardDeviations</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">;</span>

  <span class="k">const</span> <span class="n">HistogramX</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">HistogramY</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">HistogramE</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">HistogramX</span> <span class="o">&amp;</span><span class="n">mutableX</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="n">HistogramY</span> <span class="o">&amp;</span><span class="n">mutableY</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="n">HistogramE</span> <span class="o">&amp;</span><span class="n">mutableE</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>

  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="n">sharedX</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramY</span><span class="o">&gt;</span> <span class="n">sharedY</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramE</span><span class="o">&gt;</span> <span class="n">sharedE</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">setSharedX</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setSharedY</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramY</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setSharedE</span><span class="p">(</span><span class="k">const</span> <span class="n">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramE</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="histogram">
<h3><a class="toc-backref" href="#id10"><tt class="docutils literal"><span class="pre">Histogram</span></tt></a><a class="headerlink" href="#histogram" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Contains copy-on-write pointers (<tt class="docutils literal"><span class="pre">cow_ptr</span></tt>) to the x-data, y-data, and e-data.</li>
<li>Therefore: <strong>copying</strong> and return-by-value (see <tt class="docutils literal"><span class="pre">Histogram</span> <span class="pre">MatrixWorkspace::histogram(size_t)</span></tt>) <strong>is cheap</strong>!</li>
<li>The interface gives access to the data as well as the pointer:</li>
</ul>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...</span>
  <span class="c1">// Replacement for readX() and dataX() const</span>
  <span class="k">const</span> <span class="n">HistogramX</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">HistogramY</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">HistogramE</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Replacement for dataX()</span>
  <span class="n">HistogramX</span> <span class="o">&amp;</span><span class="n">mutableX</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="n">HistogramY</span> <span class="o">&amp;</span><span class="n">mutableY</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="n">HistogramE</span> <span class="o">&amp;</span><span class="n">mutableE</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>

  <span class="c1">// Replacement for refX()</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="n">sharedX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramY</span><span class="o">&gt;</span> <span class="n">sharedY</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramE</span><span class="o">&gt;</span> <span class="n">sharedE</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Replacement for setX()</span>
  <span class="kt">void</span> <span class="n">setSharedX</span><span class="p">(</span><span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setSharedY</span><span class="p">(</span><span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramY</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">setSharedE</span><span class="p">(</span><span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramE</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Note that there is also Dx-data, but it is not widely used and thus omitted from this documentation.
The interface for Dx is mostly equivalent to that for E.</p>
</div>
<div class="section" id="histogramx-histogramy-and-histograme">
<h3><a class="toc-backref" href="#id11"><tt class="docutils literal"><span class="pre">HistogramX</span></tt>, <tt class="docutils literal"><span class="pre">HistogramY</span></tt>, and <tt class="docutils literal"><span class="pre">HistogramE</span></tt></a><a class="headerlink" href="#histogramx-histogramy-and-histograme" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>The current fundamental type for x-data, <tt class="docutils literal"><span class="pre">std::vector&lt;double&gt;</span></tt>, is replaced by <tt class="docutils literal"><span class="pre">HistogramX</span></tt>.</li>
<li>The current fundamental type for y-data, <tt class="docutils literal"><span class="pre">std::vector&lt;double&gt;</span></tt>, is replaced by <tt class="docutils literal"><span class="pre">HistogramY</span></tt>.</li>
<li>The current fundamental type for e-data, <tt class="docutils literal"><span class="pre">std::vector&lt;double&gt;</span></tt>, is replaced by <tt class="docutils literal"><span class="pre">HistogramE</span></tt>.</li>
<li>Internally these are also a <tt class="docutils literal"><span class="pre">std::vector&lt;double&gt;</span></tt> and the interface is almost identical.</li>
<li>However, they do not allow for size modifications, since that could bring a histogram into an inconsistent state, e.g., by resizing the x-data without also resizing the y-data.</li>
</ul>
</div>
<div class="section" id="binedges">
<h3><a class="toc-backref" href="#id12"><tt class="docutils literal"><span class="pre">BinEdges</span></tt></a><a class="headerlink" href="#binedges" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">For algorithms that work with bin edges, <tt class="docutils literal"><span class="pre">Histogram</span></tt> provides an interface for accessing and modifying the x-data as if it were stored as bin edges:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Returns by value!</span>
  <span class="n">BinEdges</span> <span class="n">binEdges</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Accepts any arguments that can be used to construct BinEdges</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setBinEdges</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">If the histogram stores point data, <tt class="docutils literal"><span class="pre">Histogram::binEdges()</span></tt> will automatically compute the bin edges from the points.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">BinEdges</span></tt> contains a <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> to <tt class="docutils literal"><span class="pre">HistogramX</span></tt>. If the histogram stores bin edges, the <tt class="docutils literal"><span class="pre">BinEdges</span></tt> object returned by <tt class="docutils literal"><span class="pre">Histogram::binEdges()</span></tt> references the same <tt class="docutils literal"><span class="pre">HistogramX</span></tt>, i.e., there is <strong>no expensive copy</strong> involved.</p>
</li>
<li><p class="first">Setting the same <tt class="docutils literal"><span class="pre">BinEdges</span></tt> object on several histograms will share the underlying data.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Histogram::setBinEdges()</span></tt> includes a size check and throws if the histogram is incompatible with the size defined by the method arguments.</p>
</li>
</ul>
</div>
<div class="section" id="points">
<h3><a class="toc-backref" href="#id13"><tt class="docutils literal"><span class="pre">Points</span></tt></a><a class="headerlink" href="#points" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">For algorithms that work with points, <tt class="docutils literal"><span class="pre">Histogram</span></tt> provides an interface for accessing and modifying the x-data as if it were stored as points:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Returns by value!</span>
  <span class="n">Points</span> <span class="n">points</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Accepts any arguments that can be used to construct Points</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setPoints</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">If the histogram stores bin edges, <tt class="docutils literal"><span class="pre">Histogram::points()</span></tt> will automatically compute the points from the bin edges.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Points</span></tt> contains a <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> to <tt class="docutils literal"><span class="pre">HistogramX</span></tt>. If the histogram stores points, the <tt class="docutils literal"><span class="pre">Points</span></tt> object returned by <tt class="docutils literal"><span class="pre">Histogram::points()</span></tt> references the same <tt class="docutils literal"><span class="pre">HistogramX</span></tt>, i.e., there is <strong>no expensive copy</strong> involved.</p>
</li>
<li><p class="first">Setting the same <tt class="docutils literal"><span class="pre">Points</span></tt> object on several histograms will share the underlying data.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Histogram::setPoints()</span></tt> includes a size check and throws if the histogram is incompatible with the size defined by the method arguments.</p>
</li>
</ul>
</div>
<div class="section" id="counts">
<h3><a class="toc-backref" href="#id14"><tt class="docutils literal"><span class="pre">Counts</span></tt></a><a class="headerlink" href="#counts" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">For algorithms that work with counts, <tt class="docutils literal"><span class="pre">Histogram</span></tt> provides an interface for accessing and modifying the y-data as if it were stored as counts:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Returns by value!</span>
  <span class="n">Counts</span> <span class="n">counts</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Accepts any arguments that can be used to construct Counts</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCounts</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">Currently the histogram stores counts directly. If this were ever not the case, <tt class="docutils literal"><span class="pre">Histogram::counts()</span></tt> will automatically compute the counts from the frequencies.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Counts</span></tt> contains a <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> to <tt class="docutils literal"><span class="pre">HistogramY</span></tt>. If the histogram stores counts (as in the current implementation), the <tt class="docutils literal"><span class="pre">Counts</span></tt> object returned by <tt class="docutils literal"><span class="pre">Histogram::counts()</span></tt> references the same <tt class="docutils literal"><span class="pre">HistogramY</span></tt>, i.e., there is <strong>no expensive copy</strong> involved.</p>
</li>
<li><p class="first">Setting the same <tt class="docutils literal"><span class="pre">Counts</span></tt> object on several histograms will share the underlying data.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Histogram::setCounts()</span></tt> includes a size check and throws if the histogram is incompatible with the size defined by the method arguments.</p>
</li>
</ul>
</div>
<div class="section" id="frequencies">
<h3><a class="toc-backref" href="#id15"><tt class="docutils literal"><span class="pre">Frequencies</span></tt></a><a class="headerlink" href="#frequencies" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">For algorithms that work with frequencies (defined as counts divided by the bin width), <tt class="docutils literal"><span class="pre">Histogram</span></tt> provides an interface for accessing and modifying the y-data as if it were stored as frequencies:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Returns by value!</span>
  <span class="n">Frequencies</span> <span class="n">frequencies</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Accepts any arguments that can be used to construct Frequencies</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencies</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">Currently the histogram stores counts. <tt class="docutils literal"><span class="pre">Histogram::counts()</span></tt> will automatically compute the frequencies from the counts.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Frequencies</span></tt> contains a <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> to <tt class="docutils literal"><span class="pre">HistogramY</span></tt>.</p>
</li>
<li><p class="first">Setting the same <tt class="docutils literal"><span class="pre">Frequencies</span></tt> object on several histograms <strong>will not share</strong> the underlying data since a conversion is required. This is in contrast to <tt class="docutils literal"><span class="pre">BinEdges</span></tt> and <tt class="docutils literal"><span class="pre">Points</span></tt> where the internal storage mode is changed when setters are used. This is currently not the case for <tt class="docutils literal"><span class="pre">Counts</span></tt> and <tt class="docutils literal"><span class="pre">Frequencies</span></tt>, i.e., y-data is always stored as counts.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Histogram::setFrequencies()</span></tt> includes a size check and throws if the histogram is incompatible with the size defined by the method arguments.</p>
</li>
</ul>
</div>
<div class="section" id="countvariances-countstandarddeviations-frequencyvariances-and-frequencystandarddeviations">
<h3><a class="toc-backref" href="#id16"><tt class="docutils literal"><span class="pre">CountVariances</span></tt>, <tt class="docutils literal"><span class="pre">CountStandardDeviations</span></tt>, <tt class="docutils literal"><span class="pre">FrequencyVariances</span></tt>, and <tt class="docutils literal"><span class="pre">FrequencyStandardDeviations</span></tt></a><a class="headerlink" href="#countvariances-countstandarddeviations-frequencyvariances-and-frequencystandarddeviations" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">For algorithms that work with counts or frequencies, <tt class="docutils literal"><span class="pre">Histogram</span></tt> provides an interface for accessing and modifying the e-data as if it were stored as variances or standard deviations of counts or frequencies:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Return by value!</span>
  <span class="n">CountVariances</span> <span class="n">countVariances</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">CountStandardDeviations</span> <span class="n">countStandardDeviations</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">FrequencyVariances</span> <span class="n">frequencyVariances</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">FrequencyStandardDeviations</span> <span class="n">frequencyStandardDeviations</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Accept any arguments that can be used to construct the respectivy object</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCountVariances</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setCountStandardDeviations</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencyVariances</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setFrequencyStandardDeviations</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">Currently the histogram stores the standard deviations of the counts. When accessing the uncertainties via any of the other 3 types the above interface methods, <tt class="docutils literal"><span class="pre">Histogram</span></tt> will automatically compute the requested type from the standard deviations of the counts.</p>
</li>
<li><p class="first">Each of the 4 types for uncertainties contains a <tt class="docutils literal"><span class="pre">cow_ptr</span></tt> to <tt class="docutils literal"><span class="pre">HistogramE</span></tt>. In the current implementation the <tt class="docutils literal"><span class="pre">CountStandardDeviations</span></tt> object returned by <tt class="docutils literal"><span class="pre">Histogram::countStandardDeviations()</span></tt> references the same <tt class="docutils literal"><span class="pre">HistogramE</span></tt> as stored in the histogram, i.e., there is no expensive copy involved.</p>
</li>
<li><p class="first">Setting the same <tt class="docutils literal"><span class="pre">CountStandardDeviations</span></tt> object on several histograms will share the underlying data.</p>
</li>
<li><p class="first">Setting any of the other 3 uncertantity objects on several histograms will not share the underlying data, since a conversion needs to take place.</p>
</li>
<li><p class="first">All <tt class="docutils literal"><span class="pre">Histogram</span></tt> setters for uncertainties includes a size check and throw if the histogram is incompatible with the size defined by the method arguments.</p>
</li>
</ul>
</div>
<div class="section" id="code-examples">
<h3><a class="toc-backref" href="#id17">Code examples</a><a class="headerlink" href="#code-examples" title="Permalink to this headline">¶</a></h3>
<p>All new classes and functions described here are part of the module <tt class="docutils literal"><span class="pre">HistogramData</span></tt>. The following code examples assume <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">HistogramData;</span></tt>.</p>
<div class="section" id="working-with-bin-edges-and-counts">
<h4><a class="toc-backref" href="#id18">Working with bin edges and counts</a><a class="headerlink" href="#working-with-bin-edges-and-counts" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Construct like std::vector&lt;double&gt;:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="n">length</span><span class="p">);</span> <span class="c1">// initialized to 0.0</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mf">42.0</span><span class="p">);</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(...);</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">Counts</span> <span class="n">counts</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Iterators:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">BinEdges</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>
<span class="k">if</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">cbegin</span><span class="p">()</span> <span class="o">!=</span> <span class="n">edges</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
  <span class="o">*</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="c1">// Range-based for works thanks to iterators:</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span>
  <span class="n">edge</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Index operator:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">BinEdges</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>
<span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 1.0</span>
<span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 2.0</span>
<span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 4.0</span>

<span class="c1">// Only const! This is not possible:</span>
<span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="c1">// REASON: BinEdges contains a copy-on-write pointer to data, dereferencing in</span>
<span class="c1">// tight loop is expensive, so interface prevents things like this:</span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// does not compile</span>

<span class="c1">// If you need write access via index, use:</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">mutableData</span><span class="p">();</span> <span class="c1">// works similar to current dataX()</span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>

<span class="c1">// Better (for simple cases):</span>
<span class="n">edges</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="working-with-points">
<h4><a class="toc-backref" href="#id19">Working with points</a><a class="headerlink" href="#working-with-points" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// Works identically to BinEdges</span>
<span class="n">Points</span> <span class="n">points</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">};</span>
<span class="c1">// ...</span>

<span class="c1">// Type safe!</span>
<span class="n">BinEdges</span> <span class="n">edges</span><span class="p">(...);</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">edges</span><span class="p">;</span> <span class="c1">// DOES NOT COMPILE</span>

<span class="c1">// Can convert</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">Points</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span> <span class="c1">// Points are defined as mid-points between edges</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">BinEdges</span><span class="p">(</span><span class="n">points</span><span class="p">);</span> <span class="c1">// Note that this is lossy, see ConvertToHistogram</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="working-with-histograms">
<h4><a class="toc-backref" href="#id20">Working with histograms</a><a class="headerlink" href="#working-with-histograms" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Construct Histogram:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">Histogram</span> <span class="n">histogram</span><span class="p">(</span><span class="n">BinEdges</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">},</span> <span class="n">Counts</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">xMode</span><span class="p">();</span> <span class="c1">// returns Histogram::XMode::BinEdges</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Assignment:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">histogram2</span> <span class="o">=</span> <span class="n">histogram1</span><span class="p">;</span> <span class="c1">// Data is automatically shared</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Basic access:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">binEdges</span><span class="p">();</span> <span class="c1">// size 3, references Histogram::x()</span>
<span class="k">auto</span> <span class="n">points</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">points</span><span class="p">();</span> <span class="c1">// size 2, computed on the fly</span>
<span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 0.15</span>
<span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 0.3</span>
<span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">x</span><span class="p">();</span> <span class="c1">// size 3</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">mutableX</span><span class="p">();</span> <span class="c1">// size 3</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Modify bin edges:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">binEdges</span><span class="p">();</span>
<span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">setBinEdges</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Outlook (not implemented yet):</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">histogram2</span> <span class="o">+=</span> <span class="n">histogram1</span><span class="p">;</span> <span class="c1">// Checks for compatible x, adds y and e</span>

<span class="c1">/////////////////////////////////////////////////////</span>
<span class="c1">// Side remark -- bin edges and points:</span>
<span class="c1">/////////////////////////////////////////////////////</span>
<span class="n">Histogram</span> <span class="n">histogram</span><span class="p">(</span><span class="n">BinEdges</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">});</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">xMode</span><span class="p">();</span> <span class="c1">// returns Histogram::XMode::BinEdges</span>
<span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">binEdges</span><span class="p">();</span> <span class="c1">// size 3, references Histogram::x()</span>
<span class="k">auto</span> <span class="n">points</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">points</span><span class="p">();</span> <span class="c1">// size 2, computed on the fly</span>
<span class="c1">// XMode::BinEdges, size 3 is compatible with Points of size 2, so:</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">setPoints</span><span class="p">(</span><span class="n">points</span><span class="p">);</span> <span class="c1">// size check passes</span>
<span class="n">histogram</span><span class="p">.</span><span class="n">xMode</span><span class="p">();</span> <span class="c1">// returns Histogram::XMode::Points</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">binEdges</span><span class="p">();</span> <span class="c1">// size 3, computed on the fly</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">.</span><span class="n">points</span><span class="p">();</span> <span class="c1">// size 2, references Histogram::x()</span>
<span class="c1">// Note that edges is now different from its initial values (same</span>
<span class="c1">// behavior as ConvertToPointData followed by ConvertToHistogram).</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="working-with-the-new-matrixworkspace-interface">
<h4><a class="toc-backref" href="#id21">Working with the new <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt> interface</a><a class="headerlink" href="#working-with-the-new-matrixworkspace-interface" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// Setting Histograms</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inputWS</span><span class="o">-&gt;</span><span class="n">histogram</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eventWS</span><span class="o">-&gt;</span><span class="n">histogram</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// ok, histogram data computed based on events</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">BinEdges</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">},</span> <span class="n">Counts</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">));</span>
<span class="n">eventWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Points</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">});</span> <span class="c1">// throws, EventWorkspace needs bin edges</span>
<span class="n">eventWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">BinEdges</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">},</span> <span class="n">Counts</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">));</span> <span class="c1">// throws, cannot have Y data</span>
<span class="n">eventWS</span><span class="o">-&gt;</span><span class="n">setHistogram</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">BinEdges</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">});</span> <span class="c1">// ok</span>

<span class="c1">// Setting BinEdges , Counts, ...</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setCounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">);</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setCounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">42</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// Preserve sharing</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setSharedY</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inputWS</span><span class="o">-&gt;</span><span class="n">sharedY</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setCounts</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inputWS</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// also shares, &#39;Counts&#39; wraps a cow_ptr</span>
<span class="n">outputWS</span><span class="o">-&gt;</span><span class="n">setBinEdges</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inputWS</span><span class="o">-&gt;</span><span class="n">binEdges</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// shares if input storage mode is &#39;XMode::BinEdges&#39;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="legacy-interface">
<h3><a class="toc-backref" href="#id22">Legacy interface</a><a class="headerlink" href="#legacy-interface" title="Permalink to this headline">¶</a></h3>
<p>For compatibility reasons an interface to the internal data, equivalent to the old interface, is still available. Using it is discouraged, since it cannot enforce size checks!</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Histogram</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">dataX</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">dataX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MantidVec</span> <span class="o">&amp;</span><span class="n">readX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// Pointer access is slightly modified, holding a HistogramX:</span>
  <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="k">const</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
  <span class="n">Kernel</span><span class="o">::</span><span class="n">cow_ptr</span><span class="o">&lt;</span><span class="n">HistogramX</span><span class="o">&gt;</span> <span class="n">ptrX</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="rollout-status">
<h2><a class="toc-backref" href="#id23">Rollout status</a><a class="headerlink" href="#rollout-status" title="Permalink to this headline">¶</a></h2>
<p>In principle, <tt class="docutils literal"><span class="pre">Histogram</span></tt> removes the need for conversions between storage types of Y and E data, i.e., the algorithms <tt class="docutils literal"><span class="pre">ConvertToDistribution</span></tt> and <tt class="docutils literal"><span class="pre">ConvertFromDistribution</span></tt>, and manual conversions between standard deviations and variances.</p>
<ul class="simple">
<li>We have not progressed far enough with refactoring to do this.</li>
<li>Just as before the introduction of <tt class="docutils literal"><span class="pre">Histogram</span></tt>, converting the data and accessing it in the wrong way will create nonsensical results.
For example:<ul>
<li>Converting a workspace with <tt class="docutils literal"><span class="pre">ConvertToDistribution</span></tt> and then running another algorithm that interprets <tt class="docutils literal"><span class="pre">readY()</span></tt> as counts does not make sense.</li>
<li><tt class="docutils literal"><span class="pre">Histogram</span></tt> does not yet protect us from that in its current state. Running <tt class="docutils literal"><span class="pre">ConvertToDistribution</span></tt> and then accessing data as <tt class="docutils literal"><span class="pre">counts()</span></tt> or <tt class="docutils literal"><span class="pre">frequencies()</span></tt> will not convert correctly, since the <tt class="docutils literal"><span class="pre">Histogram</span></tt> does not know that an external conversion algorithm has been run on its data.</li>
</ul>
</li>
<li>It is essential to fix this as a next step, there are two options:<ul>
<li>Option A: Remove all such conversions from Mantid, if data is required as one type or another use <tt class="docutils literal"><span class="pre">counts()</span></tt> or <tt class="docutils literal"><span class="pre">frequencies()</span></tt>.</li>
<li>Option B: Make changing the storage type of Y and E data in <tt class="docutils literal"><span class="pre">Histogram</span></tt> possible. This implies that we cannot use <tt class="docutils literal"><span class="pre">Histogram::y()</span></tt> in algorithms that require <tt class="docutils literal"><span class="pre">Counts</span></tt>, since this is not guaranteed anymore.</li>
</ul>
</li>
</ul>
<p>Storing the uncertainties as standard deviations vs. storing them as variances suffers from a very similar problem.</p>
<p>Both options have shortcomings and I have currently not made up my mind about the best solution.
In any case this will be a major change and is thus not part of the initial introduction of the <tt class="docutils literal"><span class="pre">HistogramData</span></tt> module.
I would be happy about feedback or other ideas.</p>
</div>
<div class="section" id="dealing-with-problems">
<h2><a class="toc-backref" href="#id24">Dealing with problems</a><a class="headerlink" href="#dealing-with-problems" title="Permalink to this headline">¶</a></h2>
<p>There are two issues you might encounter when implementing new algorithms or when running existing scripts that are not part of our automated testing:</p>
<ol class="arabic simple">
<li>Exceptions to due size mismatch.
The <tt class="docutils literal"><span class="pre">Histogram</span></tt> type validates the size of X, Y, and E data in (non-legacy) setters.
The best solution is to determine the correct size at creation time of the workspace.
Alternatively, you can simply set a new histogram with different size via <tt class="docutils literal"><span class="pre">MatrixWorkspace::setHistogram()</span></tt> (not yet available in Python).</li>
<li>Exceptions about the storage mode of the X data, <tt class="docutils literal"><span class="pre">Histogram::Xmode</span></tt>.
This happens rarely, typically by creating a workspace that contains histogram data (bin edges) and modifying the size via the legacy interface to store point data (or vice versa).
These size modifications are only possible via the legacy interface.
The best solution is to determine the storage mode at creation time of the workspace, by specifying the correct length of the X data.
If that is not possible, use the new setters such as <tt class="docutils literal"><span class="pre">setBinEdges()</span></tt>, they will trigger a conversion of the internal storage mode (not yet available in Python).</li>
</ol>
<p><strong>Category</strong>: <a class="reference external" href="../api/python/mantid/api/categories/Concepts.html">Concepts</a></p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="GeometryofShape.html" title="Previous Chapter: Geometry of Shape"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Geometry of Shap...</span>
    </a>
  </li>
  <li>
    <a href="HowToDefineGeometricShape.html" title="Next Chapter: How To Define Geometric Shape"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">How To Define Ge... &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
      Last updated on 2019-11-18.<br/>
    </p>
  </div>
</footer>
  </body>
</html>