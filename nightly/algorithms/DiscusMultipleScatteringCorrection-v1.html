<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DiscusMultipleScatteringCorrection v1</title>
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6.4.20220909.1939',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Divide v1" href="Divide-v1.html" />
    <link rel="prev" title="DirectILLTubeBackground v1" href="DirectILLTubeBackground-v1.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="../_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>6.4</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://www.mantidproject.org">Home</a></li>
                <li><a href="http://download.mantidproject.org">Download</a></li>
                <li><a href="http://docs.mantidproject.org/nightly/">Documentation</a></li>
                <li><a href="http://www.mantidproject.org/Contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
    <p>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation</a> &#187;</li>
        
            <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Algorithms</a> &#187;</li>
          
        
        
          
            <li class="nav-item nav-item-this"><a href="">DiscusMultipleScatteringCorrection v1</a></li>
          
        
      </ul>
    </div> </p>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <p><span class="math">\(\renewcommand\AA{\unicode{x212B}}\)</span></p>
<div class="section" id="discusmultiplescatteringcorrection-v1">
<span id="algm-discusmultiplescatteringcorrection"></span><span id="algm-discusmultiplescatteringcorrection-v1"></span><h1>DiscusMultipleScatteringCorrection v1<a class="headerlink" href="#discusmultiplescatteringcorrection-v1" title="Permalink to this headline">¶</a></h1>
<div class="figure align-right" id="id6">
<span id="index-0"></span><a class="screenshot reference internal image-reference" href="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png"><img alt="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png" class="screenshot" src="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png" style="width: 349px;" /></a>
<p class="caption"><span class="caption-text"><strong>DiscusMultipleScatteringCorrection</strong> dialog.</span></p>
</div>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#summary" id="id7">Summary</a><ul>
<li><a class="reference internal" href="#see-also" id="id8">See Also</a></li>
</ul>
</li>
<li><a class="reference internal" href="#properties" id="id9">Properties</a></li>
<li><a class="reference internal" href="#description" id="id10">Description</a><ul>
<li><a class="reference internal" href="#theory" id="id11">Theory</a><ul>
<li><a class="reference internal" href="#importance-sampling" id="id12">Importance Sampling</a></li>
<li><a class="reference internal" href="#support-for-sample-environment" id="id13">Support for sample environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#outputs" id="id14">Outputs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usage" id="id15">Usage</a></li>
<li><a class="reference internal" href="#references" id="id16">References</a></li>
<li><a class="reference internal" href="#source" id="id17">Source</a></li>
</ul>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id7">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Calculates a multiple scattering correction using a Monte Carlo method</p>
<div class="section" id="see-also">
<h3><a class="toc-backref" href="#id8">See Also</a><a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="MayersSampleCorrection-v1.html#algm-mayerssamplecorrection"><span class="std std-ref">MayersSampleCorrection</span></a>, <a class="reference internal" href="CarpenterSampleCorrection-v1.html#algm-carpentersamplecorrection"><span class="std std-ref">CarpenterSampleCorrection</span></a>, <a class="reference internal" href="VesuvioCalculateMS-v1.html#algm-vesuviocalculatems"><span class="std std-ref">VesuvioCalculateMS</span></a></p>
<p>This algorithm is also known as: <strong>Muscat</strong></p>
</div>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id9">Properties</a><a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="1%" />
<col width="8%" />
<col width="2%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Direction</th>
<th class="head">Type</th>
<th class="head">Default</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>InputWorkspace</td>
<td>Input</td>
<td><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></td>
<td><em>Mandatory</em></td>
<td>The name of the input workspace.  The input workspace must have X units of Momentum (k) for elastic calculations and units of energy transfer (DeltaE) for inelastic calculations. This is used to supply the sample details, the detector positions and the x axis range to calculate corrections for</td>
</tr>
<tr class="row-odd"><td>StructureFactorWorkspace</td>
<td>Input</td>
<td><a class="reference internal" href="../concepts/Workspace.html#workspace"><span class="std std-ref">Workspace</span></a></td>
<td><em>Mandatory</em></td>
<td>The name of the workspace containing S’(q) or S’(q, w).  For elastic calculations, the input workspace must contain a single spectrum and have X units of momentum transfer. A workspace group containing one workspace per component can also be supplied if a calculation is being run on a workspace with a sample environment specified</td>
</tr>
<tr class="row-even"><td>OutputWorkspace</td>
<td>Output</td>
<td>WorkspaceGroup</td>
<td><em>Mandatory</em></td>
<td>Name for the WorkspaceGroup that will be created. Each workspace in the group contains a calculated weight for a particular number of scattering events. The number of scattering events varies from 1 up to the number supplied in the NumberOfScatterings parameter. The group will also include an additional workspace for a calculation with a single scattering event where the absorption post scattering has been set to zero</td>
</tr>
<tr class="row-odd"><td>ScatteringCrossSection</td>
<td>Input</td>
<td><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></td>
<td>&#160;</td>
<td>A workspace containing the scattering cross section as a function of k, <span class="math">\(\sigma_s(k)\)</span>. Note - this parameter would normally be left empty which results in the tabulated cross section data being used instead which implies no wavelength dependence</td>
</tr>
<tr class="row-even"><td>NumberOfSimulationPoints</td>
<td>Input</td>
<td>number</td>
<td><em>Optional</em></td>
<td>The number of points on the input workspace x axis for which a simulation is attempted</td>
</tr>
<tr class="row-odd"><td>NeutronPathsSingle</td>
<td>Input</td>
<td>number</td>
<td>1000</td>
<td>The number of “neutron” paths to generate for single scattering</td>
</tr>
<tr class="row-even"><td>NeutronPathsMultiple</td>
<td>Input</td>
<td>number</td>
<td>1000</td>
<td>The number of “neutron” paths to generate for multiple scattering</td>
</tr>
<tr class="row-odd"><td>SeedValue</td>
<td>Input</td>
<td>number</td>
<td>123456789</td>
<td>Seed the random number generator with this value</td>
</tr>
<tr class="row-even"><td>NumberScatterings</td>
<td>Input</td>
<td>number</td>
<td>2</td>
<td>Number of scatterings</td>
</tr>
<tr class="row-odd"><td>Interpolation</td>
<td>Input</td>
<td>string</td>
<td>Linear</td>
<td>Method of interpolation used to compute unsimulated values. Allowed values: [‘Linear’, ‘CSpline’]</td>
</tr>
<tr class="row-even"><td>SparseInstrument</td>
<td>Input</td>
<td>boolean</td>
<td>False</td>
<td>Enable simulation on special instrument with a sparse grid of detectors interpolating the results to the real instrument.</td>
</tr>
<tr class="row-odd"><td>NumberOfDetectorRows</td>
<td>Input</td>
<td>number</td>
<td>5</td>
<td>Number of detector rows in the detector grid of the sparse instrument.</td>
</tr>
<tr class="row-even"><td>NumberOfDetectorColumns</td>
<td>Input</td>
<td>number</td>
<td>10</td>
<td>Number of detector columns in the detector grid of the sparse instrument.</td>
</tr>
<tr class="row-odd"><td>ImportanceSampling</td>
<td>Input</td>
<td>boolean</td>
<td>False</td>
<td>Enable importance sampling on the Q value chosen on multiple scatters based on Q.S(Q)</td>
</tr>
<tr class="row-even"><td>MaxScatterPtAttempts</td>
<td>Input</td>
<td>number</td>
<td>5000</td>
<td>Maximum number of tries made to generate a scattering point within the sample. Objects with holes in them, e.g. a thin annulus can cause problems if this number is too low. If a scattering point cannot be generated by increasing this value then there is most likely a problem with the sample geometry.</td>
</tr>
<tr class="row-odd"><td>SimulateEnergiesIndependently</td>
<td>Input</td>
<td>boolean</td>
<td>False</td>
<td>For inelastic calculation, whether the results for adjacent energy transfer bins are simulated separately. Currently applies to Direct geometry only</td>
</tr>
<tr class="row-even"><td>NormalizeStructureFactors</td>
<td>Input</td>
<td>boolean</td>
<td>False</td>
<td>Enable normalization of supplied structure factor(s). May be required when running a calculation involving more than one material where the normalization of the default S(Q)=1 structure factor doesn’t match the normalization of a supplied non-isotropic structure factor</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="description">
<h2><a class="toc-backref" href="#id10">Description</a><a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>This algorithm calculates a Multiple Scattering correction using a Monte Carlo integration method.
The method uses a structure function for the sample to determine the probability of a particular momentum transfer (q) and energy transfer (<span class="math">\(\omega\)</span>) value for each scattering event and it doesn’t therefore rely on an assumption that the scattering is isotropic.</p>
<p>The structure function that the algorithm takes as input is a linear combination of the coherent and incoherent structure factors:</p>
<p><span class="math">\(S'(Q, \omega) = \frac{1}{\sigma_b}(\sigma_{coh} S(Q, \omega) + \sigma_{inc} S_s(Q, \omega))\)</span></p>
<p>If the sample is a perfectly coherent scatterer then <span class="math">\(S'(Q, \omega) = S(Q, \omega)\)</span></p>
<p>The algorithm is based on code which was originally written in Fortran as part of the Discus program <a class="footnote-reference" href="#joh" id="id1">[1]</a>. The code was subsequently resurrected and improved by Spencer Howells under the Muscat name and was included in the QENS MODES package <a class="footnote-reference" href="#how" id="id2">[2]</a>
These original programs calculated multiple scattering corrections for inelastic instruments but an elastic diffraction version of the code was also created and results from that program are included in this paper by Mancinelli <a class="footnote-reference" href="#man" id="id3">[3]</a>.</p>
<div class="section" id="theory">
<h3><a class="toc-backref" href="#id11">Theory</a><a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>The theory is outlined here for an inelastic calculation. The calculation performed for an elastic instrument is a special case of this with <span class="math">\(\omega=0\)</span>.</p>
<p>The algorithm calculates a set of dimensionless weights <span class="math">\(J_n\)</span> describing the probability of detection at an angle <span class="math">\(\theta\)</span> after n scattering events given a total incident flux <span class="math">\(I_0\)</span> and a transmitted flux of T:</p>
<p><span class="math">\(T_n(\theta,k_{in}, \omega) = J_n(\theta,k_{in}, \omega) I_0(k_{in})\)</span></p>
<p>The quantity <span class="math">\(J_n\)</span> is calculated by performing the following integration:</p>
<div class="math">
\[\begin{split}J_n &amp;= (\frac{\mu_s}{4 \pi})^n \frac{1}{A} \int dS \int_{0}^{l_1^{max}} dl_1 e^{-\mu_T l_1} \prod\limits_{i=1}^{n-1} [\int_{0}^{l_{i+1}^{max}} dl_{i+1} \int_{0}^{\pi} \sin\theta_i d\theta_i \int_{0}^{2 \pi} d\phi_i \int_{\omega^{min}}^{\omega_i^{max}} d\omega_i (e^{-\mu_T l_{i+1}}) \frac{k_{i+1}}{k_i} S(Q_i, \omega_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \\
    &amp;=(\frac{\mu_s}{4 \pi})^n \frac{1}{A} \int dS \int_{0}^{l_1^{max}} dl_1 e^{-\mu_T l_1} \prod\limits_{i=1}^{n-1} [\int_{0}^{l_{i+1}^{max}} dl_{i+1} \int_{0}^{2 \pi} d\phi_i \iint \limits_{D(k_i)} dQ_i d\omega_i (e^{-\mu_T l_{i+1}}) \frac{Q_i}{k_i^2} S(Q_i, \omega_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n)\end{split}\]</div>
<p>The variables <span class="math">\(l_i^{max}\)</span> represent the maximum path length before the next scatter given a particular phi and theta value (Q). Each <span class="math">\(l_i\)</span> is actually a function of all of the earlier values for the <span class="math">\(l_i\)</span>, <span class="math">\(\phi\)</span>, <span class="math">\(Q\)</span> and <span class="math">\(\omega\)</span> variables ie <span class="math">\(l_i = l_i(l_1, l_2, ..., l_{i-1}, \phi_1, \phi_2, ..., \phi_i, Q_1, Q_2, ..., Q_i, \omega_1, \omega_2, ..., \omega_i)\)</span>.
The integration over the variables <span class="math">\(Q\)</span> and <span class="math">\(\omega\)</span> is done over the kinematically accessible region <span class="math">\(D(k_i)\)</span>. The integral is done over <span class="math">\(\omega\)</span> first and the range is defined by the minimum value on the <span class="math">\(\omega\)</span> axis in the <span class="math">\(S(Q, \omega)\)</span> profile and a maximum which is equal to the total energy loss of the pre-scatter neutron prior to the ith scatter.
The limits on the q integration are then calculated as follows (and are also a function of i). These formulae for the q limits reduce to 0 and 2k for elastic.</p>
<p><span class="math">\(q_i^{min} = |k_{i+1} - k_i|\)</span></p>
<p><span class="math">\(q_i^{max} = q_i^{min} + 2 min(k_i, k_{i+1})\)</span></p>
<p>The following substitutions are then performed in order to make it more convenient to evaluate as a Monte Carlo integral:</p>
<p><span class="math">\(t_i = \frac{1-e^{-\mu_T l_i}}{1-e^{-\mu_T l_i^{max}}}\)</span></p>
<p><span class="math">\(u_i = \frac{\phi_i}{2 \pi}\)</span></p>
<p><span class="math">\(2 k_i^2 = \frac{\sigma_s}{\sigma_s(k_i)} I(k_i)\)</span> where <span class="math">\(I(k) = \iint \limits_{D(k)} Q S(Q, \omega) dQ d\omega\)</span></p>
<p>Using the new variables the integral is:</p>
<div class="math">
\[J_n = \frac{1}{A} \int\hspace{-3pt}dS\int_{0}^{1}\hspace{-3pt}dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1}\hspace{-3pt}dt_{i+1}\int_{0}^{1} du_i \iint \limits_{D(k_i)}\hspace{-3pt}dQ_i d\omega_i\frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T} \frac{Q_i S(Q_i, \omega_i)}{I(k_i)} \sigma_s(k_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>This is evaluated as a Monte Carlo integration by selecting random values for the variables <span class="math">\(t_i\)</span> and <span class="math">\(u_i\)</span> between 0 and 1. The integral over <span class="math">\(Q\omega\)</span> space is performed by integrating a slightly modified <span class="math">\(S(Q,\omega)\)</span> function over a rectangular region. <span class="math">\(S_{kin}(Q,\omega)\)</span> equals zero if <span class="math">\(Q\)</span> and <span class="math">\(\omega\)</span> are outside the kinematically accessible region.
The rectangular region spans the full length of the <span class="math">\(\omega\)</span> axis in the <span class="math">\(S(Q,\omega)\)</span> profile and goes from zero to the maximum possible <span class="math">\(Q_i\)</span> for a particular <span class="math">\(k_i\)</span> in the q direction.</p>
<p>A simulated path is traced through the sample to enable the <span class="math">\(l_i^{\ max}\)</span> values to be calculated. The path is traced by calculating the <span class="math">\(l_i\)</span>, <span class="math">\(\theta\)</span> and <span class="math">\(\phi\)</span> values as follows from the random variables. The code keeps a note of the start coordinates of the current path segment and updates it when moving to the next segment using these randomly selected lengths and directions:</p>
<p><span class="math">\(l_i = -\frac{1}{\mu_T}ln(1-(1-e^{-\mu_T l_i^{\ max}})t_i)\)</span></p>
<p><span class="math">\(\cos\theta_i = (k_i^2 + k_{i+1}^2 - Q_i^2)/2 k_i k_{i+1}\)</span></p>
<p><span class="math">\(\phi_i = 2 \pi u_i\)</span></p>
<p>The final Monte Carlo integration that is actually performed by the code is as follows where N is the number of scenarios:</p>
<div class="math">
\[J_n = \frac{1}{N}\sum \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T} \frac{\Delta Q_i \Delta \omega Q_i S_{kin}(Q_i, \omega_i)}{I(k_i)} \sigma_s(k_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>where the integration ranges over the rectangular <span class="math">\(Q \omega\)</span> region are defined as follows:</p>
<p><span class="math">\(\Delta\omega = \omega^{max}-\omega^{min}\)</span></p>
<p><span class="math">\(\Delta Q_i = k_i + \frac{2m}{\hbar}\sqrt{\frac{\hbar^2 k_i^2}{2m} - \omega_{min}}\)</span></p>
<p>This is similar to the formulation described in the Mancinelli paper except there is no random variable to decide whether a particular scattering event is coherent or incoherent.</p>
<p>The integral <span class="math">\(I(k)\)</span> is evaluated deterministically up front at a set of k values and interpolated as required.</p>
<p>The factor for the final track segment can also be normalised by setting <code class="docutils literal"><span class="pre">NormalizeStructureFactors=true</span></code> which replaces <span class="math">\(\sigma_s\)</span> with <span class="math">\(2k_n^2 \sigma_s(k_n)/I(k_n)\)</span>. This feature wasn’t in the original Discus implementation.</p>
<p>The results for different <span class="math">\(\omega\)</span> values can be calculated by simulating tracks separately for each <span class="math">\(\omega\)</span> value or the same tracks can be reused with the multiple weights for the final track segment being calculated to achieve the required range of overall energy transfers.
Discus used the latter approach which results in the results for different <span class="math">\(\omega\)</span> being correlated. This choice is controlled using the <code class="docutils literal"><span class="pre">SimulateEnergiesIndependently</span></code> parameter</p>
<div class="section" id="importance-sampling">
<h4><a class="toc-backref" href="#id12">Importance Sampling</a><a class="headerlink" href="#importance-sampling" title="Permalink to this headline">¶</a></h4>
<p>The algorithm includes an option to use importance sampling to improve the results for elastic instrument when running with S(Q) profiles containing spikes.
Without this option enabled, the contribution from rare, high values in the structure factor is only visible at a very high number of scenarios.</p>
<p>The importance sampling is achieved using a further change of variables as follows:</p>
<p><span class="math">\(v_i = P(Q_i) = \frac{I(Q_i)}{I(2k)}\)</span> where <span class="math">\(I(x) = \int_{0}^{x} Q S(Q) dQ\)</span></p>
<p>With this approach the Q value for each segment is chosen as follows based on a <span class="math">\(v_i\)</span> value randomly selected between 0 and 1:</p>
<p><span class="math">\(Q_i = P^{-1}(v_i)\)</span></p>
<p><span class="math">\(\cos\theta_i\)</span> is determined from <span class="math">\(Q_i\)</span> as before. The change of variables gives the following integral for <span class="math">\(J_n\)</span>:</p>
<div class="math">
\[ \begin{align}\begin{aligned}J_n = \frac{1}{A} \int dS \int_{0}^{1} dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1} dt_{i+1} \int_{0}^{1} dv_i \frac{I(2k)}{2k^2} \sigma_s \int_{0}^{1} du_i \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\\J_n = \frac{1}{A} \int dS \int_{0}^{1} dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1} dt_{i+1} \int_{0}^{1} dv_i \sigma_s(k) \int_{0}^{1} du_i \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\end{aligned}\end{align} \]</div>
<p>Finally, the equivalent Monte Carlo integration that the algorithm performs with importance sampling enabled is:</p>
<div class="math">
\[J_n = \frac{1}{N}\sum \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\sigma_s(k) \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>The importance sampling has also been implemented for inelastic instruments by flatting out the 2D <span class="math">\(S(Q, \omega)\)</span> profile into a 1D array.
A 1D coordinate is created which is the actual Q value added onto the maximum Q from the preceding <span class="math">\(\omega\)</span> row: <span class="math">\(Q'(Q,\omega_i) = Q + Q_{max}(\omega_{i-1})\)</span>
With this approach there is no interpolation performed between different <span class="math">\(\omega\)</span> values. It’s not clear whether the importance sampling is useful for inelastic calculations since the area where the multiple scattering correction tends to be largest relative to the signal is away from the peak in <span class="math">\(S(Q, \omega)\)</span>.</p>
</div>
<div class="section" id="support-for-sample-environment">
<h4><a class="toc-backref" href="#id13">Support for sample environment</a><a class="headerlink" href="#support-for-sample-environment" title="Permalink to this headline">¶</a></h4>
<p>The calculation can include scattering from the sample environment (e.g. can) in the Monte Carlo simulation. The term “segment” has previously been used to refer to a straight neutron path between two scattering events. For the purpose of this description the term “link” will be used to refer to a subsection of a segment that lies within a single material.</p>
<p>The modified calculation is illustrated here with an example of a sample contained in a can where a track may contain three different links (can, then sample, then can). If the selected scatter point occurs somewhere in the third link, the quantity <span class="math">\(t_i\)</span> is redefined as:</p>
<div class="math">
\[t_i = \frac{1-e^{-\mu_1 l_1^{max} - \mu_2 l_2^{max} - \mu_3 (l_i - l_1^{max} - l_2^{max})}}{1-e^{-\mu_1 l_1^{max} - \mu_2 l_2^{max} - \mu_3 l_3^{max}}}\]</div>
<p>This can be generally expressed as follows where n is the number of sample environment components:</p>
<div class="math">
\[t_i = \frac{1-e^{-\sum\limits_{j=1}^{n} \mu_j\ min(max( l_i - \sum\limits_{k=1}^{j-1} l_k^{max},\ 0),\ l_j^{max})}}{1-e^{-\sum\limits_{j=1}^{n} \mu_j l_j^{max}}}\]</div>
<p>Based on this the length of the ith segment can be derived from a <span class="math">\(t_i\)</span> that has been randomly selected between 0 and 1 as follows where again the expression is for the specific case of a track containing three different links:</p>
<div class="math" id="equation-l-i">
<span class="eqno">(1)<a class="headerlink" href="#equation-l-i" title="Permalink to this equation">¶</a></span>\[\mu_1 l_1^{max} + \mu_2 l_2^{max} + \mu_3 (l_i - l_1^{max} - l_2^{max}) = - ln(1-(1-e^{-\sum\limits_{j=1}^{n}\mu_j l_j^{max}})t_i)\]</div>
<p>…and more generally (although perhaps less helpfully in terms of explaining how the code works):</p>
<div class="math">
\[\sum\limits_{j=1}^{n} \mu_j\ min(max( l_i - \sum\limits_{k=1}^{j-1} l_k^{max},\ 0),\ l_j^{max}) = - ln(1-(1-e^{-\sum\limits_{j=1}^{n}\mu_j l_j^{max}})t_i)\]</div>
<p>It can be seen that the formula <a class="reference internal" href="#equation-l-i">(1)</a> can be solved for <span class="math">\(l_i\)</span> by calculating the quantity on the right hand side and then sequentially subtracting <span class="math">\(\mu_i l_i^{max}\)</span> from it for increasing i while keeping the running total &gt;=0.
The value of <span class="math">\(i\)</span> when you can’t subtract any more <span class="math">\(\mu_i l_i^{max}\)</span> identifies the component containing the scatter. Dividing by <span class="math">\(\mu_i\)</span> at this point gives you the length into that component that the track reaches.</p>
<p>The other modification to the calculation to support scattering in the sample environment is that a different structure factor <span class="math">\(S(Q,\omega)\)</span> , <span class="math">\(I(k)\)</span> and scattering cross section <span class="math">\(\sigma_s\)</span> is required for each material. The component containing each scatter is derived from the <span class="math">\(l_i\)</span> calculation and is used to look up the material.</p>
</div>
</div>
<div class="section" id="outputs">
<h3><a class="toc-backref" href="#id14">Outputs</a><a class="headerlink" href="#outputs" title="Permalink to this headline">¶</a></h3>
<p>The algorithm outputs a workspace group containing the following workspaces:</p>
<ul class="simple">
<li>Several workspaces called <code class="docutils literal"><span class="pre">Scatter_n</span></code> where n is the number of scattering events considered. Each workspace contains “per detector” weights as a function of momentum or energy transfer for a specific number of scattering events. The number of scattering events ranges between 1 and the number specified in the NumberOfScatterings parameter</li>
<li>Several workspaces called <code class="docutils literal"><span class="pre">Scatter_n_Integrated</span></code> which are integrals of the <code class="docutils literal"><span class="pre">Scatter_n</span></code> workspaces across the x axis (Momentum for elastic and DeltaE for inelastic)</li>
<li>A workspace called <code class="docutils literal"><span class="pre">Scatter_1_NoAbsorb</span></code> is also created for a scenario where neutrons are scattered once, absorption is assumed to be zero and re-scattering after the simulated scattering event is assumed to be zero. This is the quantity <span class="math">\(J_{1}^{*}\)</span> described in the Discus manual</li>
<li>A workspace called <code class="docutils literal"><span class="pre">Scatter_2_n_Summed</span></code> which is the sum of the <code class="docutils literal"><span class="pre">Scatter_n</span></code> workspaces for n &gt; 1</li>
<li>A workspace called <code class="docutils literal"><span class="pre">Scatter_1_n_Summed</span></code> which is the sum of the <code class="docutils literal"><span class="pre">Scatter_n</span></code> workspaces for n &gt;= 1</li>
<li>A workspace called <code class="docutils literal"><span class="pre">Ratio_Single_To_All</span></code> which is the <code class="docutils literal"><span class="pre">Scatter_1</span></code> workspace divided by <code class="docutils literal"><span class="pre">Scatter_1_n_Summed</span></code></li>
</ul>
<p>The output can be applied to a workspace containing a real sample measurement in one of two ways:</p>
<ul class="simple">
<li>subtraction method. The additional intensity contributed by multiple scattering to either a raw measurement or a vanadium corrected measurement can be calculated from the weights output from this algorithm. The additional intensity can then be subtracted to give an idealised “single scatter” intensity.
For example, the additional intensity measured at a detector due to multiple scattering is given by <span class="math">\((\sum_{n=2}^{\infty} J_n) E(\lambda) I_0(\lambda) \Delta \Omega\)</span> where <span class="math">\(E(\lambda)\)</span> is the detector efficiency, <span class="math">\(I_0(\lambda)\)</span> is the incident intensity and <span class="math">\(\Delta \Omega\)</span> is the solid angle subtended by the detector.
The factors <span class="math">\(E(\lambda) I_0(\lambda) \Delta \Omega\)</span> can be obtained from a Vanadium run - although to take advantage of the “per detector” multiple scattering weights, the preparation of the Vanadium data will need to take place “per detector” instead of on focussed datasets</li>
<li>factor method. The correction can be applied by multiplying the real sample measurement by <span class="math">\(J_1/\sum_{n=1}^{\infty} J_n\)</span>. This approach avoids having to create a suitably normalised intensity from the weights and the method is also more tolerant of any normalisation inaccuracies in the S(Q) profile</li>
</ul>
<p>The multiple scattering correction should be applied before applying an absorption correction.</p>
<p>The Discus manual describes a further method of applying an attenuation correction and a multiple scattering correction in one step using a variation of the factor method. To achieve this the real sample measurement should be multipled by <span class="math">\(J_1^{*}/(\sum_{n=1}^{\infty} J_n\)</span>).
Note that this differs from the approach taken in other Mantid absorption correction algorithms such as MonteCarloAbsorption because of the properties of <span class="math">\(J_{1}^{*}\)</span>.
<span class="math">\(J_{1}^{*}\)</span> corrects for attenuation due to absorption before and after the simulated scattering event (which is the same as MonteCarloAbsorption) but it only corrects for attenuation due to scattering after the simulated scattering event.
For this reason it’s not clear this feature from Discus is useful but it has been left in for historical reasons.</p>
<p>The sample shape (and optionally the sample environment shape) can be specified by running the algorithms <a class="reference internal" href="SetSample-v1.html#algm-setsample"><span class="std std-ref">SetSample</span></a> or <a class="reference internal" href="LoadSampleShape-v1.html#algm-loadsampleshape"><span class="std std-ref">LoadSampleShape</span></a> on the input workspace prior to running this algorithm.</p>
<p>The algorithm can take a long time to run on instruments with a lot of spectra andor a lot of bins in each spectrum. The run time can be reduced by enabling the following interpolation features:</p>
<ul class="simple">
<li>the multiple scattering correction can be calculated on a subset of the bins in the input workspace by specifying a non-default value for NumberOfSimulationPoints. The other points will be calculated by interpolation</li>
<li>the algorithm can be performed on a subset of the detectors by setting SparseInstrument=True</li>
</ul>
<p>Both of these interpolation features are described further in the documentation for the <a class="reference internal" href="MonteCarloAbsorption-v1.html#algm-montecarloabsorption"><span class="std std-ref">MonteCarloAbsorption</span></a> algorithm</p>
</div>
</div>
<div class="section" id="usage">
<h2><a class="toc-backref" href="#id15">Usage</a><a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p><strong>Example - elastic calculation on single spike S(Q) and an isotropic S(Q) for comparison</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span> <span class="nn">mantid</span> <span class="kn">import</span> <span class="n">mtd</span>
<span class="kn">from</span> <span class="nn">mantid.simpleapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># S(Q) consisting of single spike at q=1</span>
<span class="c1"># Spike height gives same normalisation as isotropic (integral of Q.S(Q) the same)</span>
<span class="n">X</span><span class="o">=</span><span class="p">[</span><span class="mf">0.99</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.01</span><span class="p">]</span>
<span class="n">Y</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
<span class="n">Sofq</span><span class="o">=</span><span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">)</span>

<span class="c1"># Isotropic S(Q)</span>
<span class="n">X</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
<span class="n">Y</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
<span class="n">Sofq_isotropic</span><span class="o">=</span><span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">)</span>

<span class="n">two_thetas</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">180</span><span class="p">):</span>
    <span class="n">two_thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># workspace with single bin centred at k=1 Angstrom-1</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">WorkspaceType</span><span class="o">=</span><span class="s2">&quot;Histogram&quot;</span><span class="p">,</span>
                           <span class="n">XUnit</span><span class="o">=</span><span class="s2">&quot;Momentum&quot;</span><span class="p">,</span>
                           <span class="n">Xmin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                           <span class="n">Xmax</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">EditInstrumentGeometry</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span>
    <span class="n">PrimaryFlightPath</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span>
    <span class="n">SpectrumIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">Polar</span><span class="o">=</span><span class="n">two_thetas</span><span class="p">,</span>
    <span class="n">Azimuthal</span><span class="o">=</span><span class="p">[</span><span class="mf">90.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">DetectorIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="n">sphere_xml</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">&lt;sphere id=&#39;some-sphere&#39;&gt; </span><span class="se">\</span>
<span class="s2">    &lt;centre x=&#39;0.0&#39;  y=&#39;0.0&#39; z=&#39;0.0&#39; /&gt; </span><span class="se">\</span>
<span class="s2">    &lt;radius val=&#39;0.01&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&lt;/sphere&gt; </span><span class="se">\</span>
<span class="s2">&lt;algebra val=&#39;some-sphere&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&quot;</span>
<span class="n">SetSample</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span>
          <span class="n">Geometry</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Shape&#39;</span><span class="p">:</span> <span class="s1">&#39;CSG&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">:</span> <span class="n">sphere_xml</span><span class="p">},</span>
          <span class="n">Material</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NumberDensity&#39;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s1">&#39;AttenuationXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s1">&#39;CoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;IncoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;ScatteringXSection&#39;</span><span class="p">:</span> <span class="mf">80.0</span><span class="p">})</span>

<span class="n">results_group</span> <span class="o">=</span> <span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">Sofq</span><span class="p">,</span>
                                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResults&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">ImportanceSampling</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># Can&#39;t index into workspace group by name (yet) so just get the members from the ADS instead</span>
<span class="n">Scatter_1_DeltaFunction</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">)</span>
<span class="n">Scatter_2_DeltaFunction</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">)</span>
<span class="n">DeleteWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults&#39;</span><span class="p">)</span>

<span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">Sofq_isotropic</span><span class="p">,</span>
                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResultsIsotropic&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">ImportanceSampling</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">Scatter_2_Isotropic</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResultsIsotropic_Scatter_2&#39;</span><span class="p">)</span>


<span class="c1"># q=2ksin(theta), so q spike corresonds to single scatter spike at ~60 degrees, double scatter spikes at 0 and 120 degrees</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_2_DeltaFunction&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_1_DeltaFunction&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">msplot</span><span class="p">)</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_2_Isotropic&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">msplot</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Spectrum (~scattering angle in degrees)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Single and Double Scatter Intensities&quot;</span><span class="p">)</span>
<span class="n">mtd</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.py">Source code</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.png">png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.hires.png">hires.png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/DiscusMultipleScatteringCorrection-v1-1.png" src="../_images/DiscusMultipleScatteringCorrection-v1-1.png" />
</div>
<p>The double scatter profile shows a similar shape to the analytic result calculated in <a class="footnote-reference" href="#may" id="id4">[4]</a>:</p>
<div class="figure">
<img alt="../_images/MayersMultipleScatteringFigure9.png" src="../_images/MayersMultipleScatteringFigure9.png" />
</div>
<p><strong>Example - inelastic calculation on direct geometry (matches calculation in DISCUS paper</strong> <a class="footnote-reference" href="#joh" id="id5">[1]</a> <strong>figure 1)</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span> <span class="nn">mantid.simpleapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># parameterised Lorentzian S(Q,w) from Discus pdf</span>
<span class="c1"># wavelength = 4 Angstroms, k=1.57</span>
<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">SpecAxis</span> <span class="o">=</span><span class="p">[],[],[]</span>
<span class="n">qmin</span><span class="p">,</span> <span class="n">qmax</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span><span class="mf">4.0</span>
<span class="n">nqpts</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.85</span><span class="p">,</span> <span class="mf">5.85</span> <span class="c1"># meV</span>
<span class="n">nwpts</span> <span class="o">=</span> <span class="mi">79</span> <span class="c1"># negative w is given explicitly so ~double number of pts in Discus</span>
<span class="n">D</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># Angstom-2 meV -1 = 2.3E-05 cm2 s-1</span>
<span class="n">TEMP</span><span class="o">=</span><span class="mi">300</span>
<span class="n">HOVERT</span> <span class="o">=</span> <span class="mf">11.6087</span><span class="o">/</span><span class="n">TEMP</span>
<span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqpts</span><span class="p">):</span>
   <span class="n">q</span> <span class="o">=</span> <span class="n">iq</span> <span class="o">*</span> <span class="p">(</span><span class="n">qmax</span><span class="o">-</span><span class="n">qmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nqpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">qmin</span>
   <span class="n">SpecAxis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwpts</span><span class="p">):</span>
     <span class="n">w</span> <span class="o">=</span> <span class="n">iw</span> <span class="o">*</span> <span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">wmin</span>
     <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">==</span><span class="mf">0.</span><span class="p">):</span>
        <span class="c1"># Discus S(Q,w) has zero here so do likewise</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Denominator zero so outputting S(q,w)=0&quot;</span><span class="p">)</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
     <span class="k">else</span><span class="p">:</span>
        <span class="n">Sqw</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Apply detailed balance, neutrons more likely to lose energy in each scatter</span>
        <span class="c1"># Mantid has w = Ei-Ef</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">):</span>
           <span class="n">Sqw</span> <span class="o">=</span> <span class="n">Sqw</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">HOVERT</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="c1"># S(Q,w) is capped at exactly 4.0 for some reason in Discus example</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Sqw</span><span class="p">,</span><span class="mf">4.0</span><span class="p">))</span>

<span class="n">sqw</span> <span class="o">=</span> <span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;DeltaE&quot;</span><span class="p">,</span>
                      <span class="n">VerticalAxisUnit</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">,</span>
                      <span class="n">VerticalAxisValues</span><span class="o">=</span><span class="n">SpecAxis</span><span class="p">,</span> <span class="n">NSpec</span><span class="o">=</span><span class="n">nqpts</span><span class="p">)</span>

<span class="n">two_thetas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">]</span>

<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">WorkspaceType</span><span class="o">=</span><span class="s2">&quot;Histogram&quot;</span><span class="p">,</span>
                           <span class="n">XUnit</span><span class="o">=</span><span class="s2">&quot;DeltaE&quot;</span><span class="p">,</span>
                           <span class="n">Xmin</span><span class="o">=</span><span class="n">wmin</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">Xmax</span><span class="o">=</span><span class="n">wmax</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="c1"># set up ring of detectors in yz plane</span>
<span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">EditInstrumentGeometry</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span>
    <span class="n">PrimaryFlightPath</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span>
    <span class="n">SpectrumIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">Polar</span><span class="o">=</span><span class="n">two_thetas</span><span class="p">,</span>
    <span class="c1">#azimuthal angle=phi, phi=0 along x axis and increases as move towards vertical y axis</span>
    <span class="n">Azimuthal</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">90.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">DetectorIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="c1"># flat plate sample 5cm x 5cm x 0.065cm</span>
<span class="n">cuboid_xml</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">&lt;cuboid id=&#39;flatplate&#39;&gt; </span><span class="se">\</span>
<span class="s2">  &lt;width val=&#39;0.05&#39; /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;height val=&#39;0.05&#39;  /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;depth  val=&#39;0.00065&#39; /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;centre x=&#39;0.0&#39; y=&#39;0.0&#39; z=&#39;0.0&#39;  /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;rotate x=&#39;45&#39; y=&#39;0&#39; z=&#39;0&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&lt;/cuboid&gt; </span><span class="se">\</span>
<span class="s2">&quot;</span>
<span class="n">SetSample</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span>
          <span class="n">Geometry</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Shape&#39;</span><span class="p">:</span> <span class="s1">&#39;CSG&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">:</span> <span class="n">cuboid_xml</span><span class="p">},</span>
          <span class="n">Material</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NumberDensity&#39;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s1">&#39;AttenuationXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s1">&#39;CoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;IncoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;ScatteringXSection&#39;</span><span class="p">:</span> <span class="mf">80.0</span><span class="p">})</span>

<span class="c1">#match Ei value from DISCUS pdf Figure 1</span>
<span class="n">ws</span><span class="o">.</span><span class="n">run</span><span class="p">()</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s2">&quot;deltaE-mode&quot;</span><span class="p">,</span> <span class="s2">&quot;Direct&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">);</span>
<span class="n">ws</span><span class="o">.</span><span class="n">run</span><span class="p">()</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s2">&quot;Ei&quot;</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">,</span> <span class="bp">True</span><span class="p">);</span>

<span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">sqw</span><span class="p">,</span>
                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResults&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># reverse w axis because Discus w = Ef-Ei (opposite to Mantid)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setY</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setY</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span><span class="s1">&#39;mantid&#39;</span><span class="p">})</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">],</span> <span class="n">wkspIndex</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Single: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; degrees&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">],</span> <span class="n">wkspIndex</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Double: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; degrees&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mf">7.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Inelastic Double</span><span class="se">\\</span><span class="s2">Single Scattering Weights&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">mtd</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.py">Source code</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.png">png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.hires.png">hires.png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/DiscusMultipleScatteringCorrection-v1-2.png" src="../_images/DiscusMultipleScatteringCorrection-v1-2.png" />
</div>
<p>This is the equivalent plot from the original Discus Fortran program:</p>
<div class="figure">
<img alt="../_images/DiscusMultipleScatteringFigure1.png" src="../_images/DiscusMultipleScatteringFigure1.png" />
</div>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id16">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="joh" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> M W Johnson, 1974 AERE Report R7682, Discus: A computer program for the calculating of multiple scattering effects in inelastic neutron scattering experiments</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="how" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>WS Howells, V Garcia Sakai, F Demmel, MTF Telling, F Fernandez-Alonso, Feb 2010, MODES manual RAL-TR-2010-006, <a class="reference external" href="https://doi.org/10.5286/raltr.2010006">doi: 10.5286/raltr.2010006</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="man" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>R Mancinelli 2012 <em>J. Phys.: Conf. Ser.</em> <strong>340</strong> 012033, Multiple neutron scattering corrections. Some general equations to do fast evaluations <a class="reference external" href="https://doi.org/10.1088/1742-6596/340/1/012033">doi: 10.1088/1742-6596/340/1/012033</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="may" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>J Mayers, R Cywinski, 1985 <em>Nuclear Instruments and Methods in Physics Research</em> A241, A Monte Carlo Evaluation Of Analytical Multiple Scattering Corrections For Unpolarised Neutron Scattering And Polarisation Analysis Data <a class="reference external" href="https://doi.org/10.1016/0168-9002(85)90607-2">doi: 10.1016/0168-9002(85)90607-2</a></td></tr>
</tbody>
</table>
<p><strong>Categories</strong>: <a class="reference external" href="categories/AlgorithmIndex.html">AlgorithmIndex</a> | <a class="reference external" href="categories/CorrectionFunctions.html">CorrectionFunctions</a></p>
</div>
<div class="section" id="source">
<h2><a class="toc-backref" href="#id17">Source</a><a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h2>
<p>C++ header: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/34d8076c38ee24128cff66d5dfa6be380c8f35dc/Framework/Algorithms/inc/MantidAlgorithms/DiscusMultipleScatteringCorrection.h">DiscusMultipleScatteringCorrection.h</a></p>
<p>C++ source: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/34d8076c38ee24128cff66d5dfa6be380c8f35dc/Framework/Algorithms/src/DiscusMultipleScatteringCorrection.cpp">DiscusMultipleScatteringCorrection.cpp</a></p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="DirectILLTubeBackground-v1.html" title="Previous Chapter: DirectILLTubeBackground v1"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; DirectILLTube...</span>
    </a>
  </li>
  <li>
    <a href="Divide-v1.html" title="Next Chapter: Divide v1"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Divide v1 &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>