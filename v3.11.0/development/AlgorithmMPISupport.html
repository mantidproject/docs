<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MPI Support for Algorithms</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.3.6/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="" href="../index.html" />
    <link rel="up" title="Development" href="index.html" />
    <link rel="next" title="ISIS SANS Reduction Back-end" href="ISISSANSReductionBackend.html" />
    <link rel="prev" title="Development" href="index.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="../_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>3.11</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://www.mantidproject.org">Home</a></li>
                <li><a href="http://download.mantidproject.org">Download</a></li>
                <li><a href="http://www.mantidproject.org/Documentation">Documentation</a></li>
                <li><a href="http://www.mantidproject.org/Contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="mpi-support-for-algorithms">
<span id="algorithmmpisupport"></span><h1>MPI Support for Algorithms<a class="headerlink" href="#mpi-support-for-algorithms" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#concept" id="id3">Concept</a><ul>
<li><a class="reference internal" href="#introduction" id="id4">Introduction</a></li>
<li><a class="reference internal" href="#spectrum-and-detector" id="id5">Spectrum and Detector</a></li>
<li><a class="reference internal" href="#storage-mode" id="id6">Storage Mode</a></li>
<li><a class="reference internal" href="#execution-mode" id="id7">Execution Mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-and-running-mantid-with-mpi-support" id="id8">Building and Running Mantid with MPI Support</a><ul>
<li><a class="reference internal" href="#build-with-mpi-support" id="id9">Build with MPI support</a></li>
<li><a class="reference internal" href="#writing-and-running-python-scripts" id="id10">Writing and running Python scripts</a></li>
<li><a class="reference internal" href="#logging-output" id="id11">Logging output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-mpi-support-for-an-algorithm" id="id12">Implementing MPI Support for an Algorithm</a><ul>
<li><a class="reference internal" href="#supported-workspace-types" id="id13">Supported workspace types</a></li>
<li><a class="reference internal" href="#mechanism" id="id14">Mechanism</a></li>
<li><a class="reference internal" href="#identical-execution" id="id15">Identical execution</a></li>
<li><a class="reference internal" href="#distributed-execution" id="id16">Distributed execution</a></li>
<li><a class="reference internal" href="#master-only-execution" id="id17">Master-only execution</a></li>
<li><a class="reference internal" href="#setting-spectrum-numbers" id="id18">Setting spectrum numbers</a></li>
<li><a class="reference internal" href="#workspace-indices" id="id19">Workspace indices</a></li>
<li><a class="reference internal" href="#instrument-and-detectors" id="id20">Instrument and detectors</a></li>
<li><a class="reference internal" href="#gui" id="id21">GUI</a></li>
<li><a class="reference internal" href="#units-tests" id="id22">Units Tests</a></li>
<li><a class="reference internal" href="#documentation" id="id23">Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#supported-algorithms" id="id24">Supported Algorithms</a></li>
</ul>
</div>
<div class="section" id="concept">
<h2><a class="toc-backref" href="#id3">Concept</a><a class="headerlink" href="#concept" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3><a class="toc-backref" href="#id4">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>MPI support in Mantid is based on processing a subset of spectra on each MPI rank.
Many algorithms process each spectrum independently so this is an efficient way of splitting the computational effort and data volume.</p>
<p>Note that the multi-dimensional workspaces <tt class="docutils literal"><span class="pre">MDHistoWorkspace</span></tt> and <tt class="docutils literal"><span class="pre">MDEventWorkspace</span></tt> handle data differently and thus cannot be dealt with in this way.
MPI support for these multi-dimensional workspaces is beyond the scope of this document.</p>
</div>
<div class="section" id="spectrum-and-detector">
<h3><a class="toc-backref" href="#id5">Spectrum and Detector</a><a class="headerlink" href="#spectrum-and-detector" title="Permalink to this headline">¶</a></h3>
<p>In Mantid the terms spectrum and detector are used interchangeably at times, leading to unnecessary confusion.
In particular, it is sometimes assumed that there is a 1:1 correspondence between spectra and detectors.
It is important to clearly distinguish between a spectrum and a detector, especially in the context of MPI support.
We may define the terms as follows:</p>
<ul class="simple">
<li>A <strong>detector</strong> is a single pixel of the instrument. Data obtained from it may be used to create a list or histogram of neutron events. If the detector can move, it can contribute to more than one list or histogram of neutron events.</li>
<li>A <strong>spectrum</strong> is a list or histogram of neutron events collected in a specific region of (typically) space. The data contained in the spectrum is data obtained from on one or more detectors.</li>
</ul>
<p>Examples may help to clarify this:</p>
<ul class="simple">
<li>If the detectors are not moveable, a 1:1 mapping is the most common.</li>
<li>Some beamlines at ISIS group multiple detectors into a single spectrum, so the region of space corresponding to a spectrum is larger than a single detector pixel.</li>
<li>After running algorithms like <tt class="docutils literal"><span class="pre">SumSpectra</span></tt> or <tt class="docutils literal"><span class="pre">DiffractionFocussing</span></tt>, a spectrum will contain data from more than one detector, even if there was an initial 1:1 correspondence.</li>
<li>If the detectors are moveable, a spectrum would correspond to a region of space given by the position a specific detector had in a certain time interval.</li>
<li>There can be detectors without a corresponding spectrum, and Mantid is thus not handling data of those detectors.</li>
</ul>
<p>For the purpose of MPI support, Mantid always stores the complete instrument including <strong>all detectors</strong> on <strong>every MPI rank</strong>. <a class="footnote-reference" href="#split-instrument" id="id1">[1]</a>
Only a subset of all spectra is stored on the local MPI rank, so a detector may be locally without corresponding spectrum but have a spectrum associated to it on another MPI rank.</p>
</div>
<div class="section" id="storage-mode">
<h3><a class="toc-backref" href="#id6">Storage Mode</a><a class="headerlink" href="#storage-mode" title="Permalink to this headline">¶</a></h3>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-storage-modes.png" src="../_images/MPI-storage-modes.png" />
<p class="caption">Visualization of available storage modes. In this and the following figures a vertical column is used to depict an MPI rank.</p>
</div>
<p>Not all data in an MPI-based data reduction can be or has to be distributed.
Some data may be present on all ranks or only on a single rank.
To formalize this concept a <tt class="docutils literal"><span class="pre">Workspace</span></tt> in Mantid now has an associated storage mode (<tt class="docutils literal"><span class="pre">Parallel::StorageMode</span></tt>), as visualized in the figure on the right.
The storage mode of a workspace can be obtained by calling <tt class="docutils literal"><span class="pre">Workspace::storageMode()</span></tt>.
There are three available storage modes</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt> implies that the data is not split and each rank holds a complete and identical clone.</li>
<li><tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt> implies that each rank holds a subset of the data and that the combination of all subsets gives the full data.</li>
<li><tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt> implies that only the master rank (rank 0) has the data.</li>
</ul>
<p>Currently only workspaces have an associated storage mode.
For all other data, such as a scalar value provided as an input to an algorithm are implicitly assumed to have <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>, i.e., have the same value on all MPI ranks.</p>
<p>Usage examples for the storage modes could include:</p>
<ul class="simple">
<li>A workspace containing the neutron monitors could be used for normalization on all ranks and could use <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>.</li>
<li>A workspace containing the data for all detector pixels would usually use <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>.</li>
<li>A workspace containing the result of summing all spectra, such as obtained from <tt class="docutils literal"><span class="pre">DiffractionFocussing</span></tt> would usually use <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>.</li>
</ul>
</div>
<div class="section" id="execution-mode">
<h3><a class="toc-backref" href="#id7">Execution Mode</a><a class="headerlink" href="#execution-mode" title="Permalink to this headline">¶</a></h3>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-identical.png" src="../_images/MPI-execution-mode-identical.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::Identical</span></tt> based on an input and output workspace with <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>. Example: <tt class="docutils literal"><span class="pre">ConvertUnits</span></tt>, <tt class="docutils literal"><span class="pre">Rebin</span></tt>, or many other algorithm that do not load or save data.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-distributed-load.png" src="../_images/MPI-execution-mode-distributed-load.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::Distributed</span></tt> creating an output workspace with <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>. Example: <tt class="docutils literal"><span class="pre">LoadEventNexus</span></tt>.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-distributed.png" src="../_images/MPI-execution-mode-distributed.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::Distributed</span></tt> based on an input and output workspace with <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>. Example: <tt class="docutils literal"><span class="pre">ConvertUnits</span></tt> or <tt class="docutils literal"><span class="pre">Rebin</span></tt>.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-distributed-gather.png" src="../_images/MPI-execution-mode-distributed-gather.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::Distributed</span></tt> based on an input workspace with <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt> creating an output workspace with <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>. Example: <tt class="docutils literal"><span class="pre">DiffractionFocussing</span></tt>.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-master-only-load.png" src="../_images/MPI-execution-mode-master-only-load.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> creating an output workspace with <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>. Example: <tt class="docutils literal"><span class="pre">LoadEventNexus</span></tt> or other load algorithms.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-master-only.png" src="../_images/MPI-execution-mode-master-only.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> based on an input and output workspace with <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>. Example: <tt class="docutils literal"><span class="pre">ConvertUnits</span></tt>, <tt class="docutils literal"><span class="pre">Rebin</span></tt>, or many other algorithm that do not load or save data.</p>
</div>
<div class="figure align-right" style="width: 25%">
<img alt="../_images/MPI-execution-mode-master-only-store.png" src="../_images/MPI-execution-mode-master-only-store.png" />
<p class="caption"><tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> based on an input workspace with <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt> an no output. Example: <tt class="docutils literal"><span class="pre">Save</span></tt> or any other save algorithm.</p>
</div>
<p>Just like the storage mode describes how data is stored, and execution mode describes how an algorithm is executed on this data.
There are five execution modes (in namespace <tt class="docutils literal"><span class="pre">Parallel</span></tt>):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ExecutionMode::Invalid</span></tt> is used to indicate that execution is not possible, e.g., if the storage modes of the inputs are inconsistent.</li>
<li><tt class="docutils literal"><span class="pre">ExecutionMode::Serial</span></tt> is used for serial execution, i.e., in non-MPI builds of Mantid or if there is only a single MPI rank. Having this mode allows for running algorithms that do not support MPI in MPI builds by running only with a single MPI rank.</li>
<li><tt class="docutils literal"><span class="pre">ExecutionMode::Identical</span></tt> is used for running an algorithm in an identical way on all MPI ranks. This would typically be used if the input workspaces have <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ExecutionMode::Distributed</span></tt> is used for running an algorithm in a distributed way across all MPI ranks. This would typically be used if the input workspaces have <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> is typically used for running an algorithm if the input workspaces have <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>.</li>
</ul>
<p>The use of the word &#8216;typically&#8217; above is intentional and indicates that there may be other cases.
In particular, an algorithm may cause a transition from one storage mode to another, or may take inputs with different storage modes.
Examples are given in the series of figures on the right.</p>
</div>
</div>
<div class="section" id="building-and-running-mantid-with-mpi-support">
<h2><a class="toc-backref" href="#id8">Building and Running Mantid with MPI Support</a><a class="headerlink" href="#building-and-running-mantid-with-mpi-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="build-with-mpi-support">
<h3><a class="toc-backref" href="#id9">Build with MPI support</a><a class="headerlink" href="#build-with-mpi-support" title="Permalink to this headline">¶</a></h3>
<p>To build Mantid with MPI support as described in this document run <tt class="docutils literal"><span class="pre">cmake</span></tt> with the additional option <tt class="docutils literal"><span class="pre">-DMPI_EXPERIMENTAL=ON</span></tt>.
This requires <tt class="docutils literal"><span class="pre">boost-mpi</span></tt> and a working MPI installation.</p>
</div>
<div class="section" id="writing-and-running-python-scripts">
<h3><a class="toc-backref" href="#id10">Writing and running Python scripts</a><a class="headerlink" href="#writing-and-running-python-scripts" title="Permalink to this headline">¶</a></h3>
<p>In principle Python scripts that use only algorithms that support MPI can be run with MPI <strong>without changes</strong>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">mantid.simpleapi</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">dataX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">dataY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">dataE</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="c"># CreateWorkspace has a new property called ParallelStorageMode that allows setting the</span>
<span class="c"># desired storage mode. It defaults to &quot;Parallel::StorageMode::Cloned&quot;.</span>
<span class="n">dataWS</span> <span class="o">=</span> <span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">dataX</span><span class="p">,</span> <span class="n">DataY</span><span class="o">=</span><span class="n">dataY</span><span class="p">,</span> <span class="n">DataE</span><span class="o">=</span><span class="n">dataE</span><span class="p">,</span> <span class="n">NSpec</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">UnitX</span><span class="o">=</span><span class="s">&quot;Wavelength&quot;</span><span class="p">,</span> <span class="n">ParallelStorageMode</span><span class="o">=</span><span class="s">&quot;Parallel::StorageMode::Distributed&quot;</span><span class="p">)</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">Rebin</span><span class="p">(</span><span class="n">dataWS</span><span class="p">,</span> <span class="s">&quot;1,1,7&quot;</span><span class="p">);</span>

<span class="k">print</span><span class="p">(</span><span class="s">&quot;Histograms: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;(Local) workspace index: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">readX</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">readY</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>Run Python with <tt class="docutils literal"><span class="pre">mpirun</span></tt> and the desired number of MPI ranks:</p>
<div class="highlight-sh"><div class="highlight"><pre>mpirun -n 3 python test.py
</pre></div>
</div>
<p>Note that directly using the Mantid Python wrapper <tt class="docutils literal"><span class="pre">mantidpython</span></tt> is not possible, i.e., <tt class="docutils literal"><span class="pre">mpirun</span> <span class="pre">-n</span> <span class="pre">3</span> <span class="pre">mantidpython</span> <span class="pre">test.py</span></tt> does not work.
Instead the correct paths to Mantid and library preloads should be set manually.
Alternatively, a modified version of <tt class="docutils literal"><span class="pre">mantidpython</span></tt> that internally uses <tt class="docutils literal"><span class="pre">mpirun</span></tt> to call python could be created.</p>
<p>Possible output:</p>
<div class="highlight-sh"><div class="highlight"><pre>CreateWorkspace-<span class="o">[</span>Notice<span class="o">]</span> CreateWorkspace started
CreateWorkspace-<span class="o">[</span>Notice<span class="o">]</span> CreateWorkspace successful, Duration 0.02 seconds
Rebin-<span class="o">[</span>Notice<span class="o">]</span> Rebin started
Rebin-<span class="o">[</span>Notice<span class="o">]</span> Rebin successful, Duration 0.01 seconds
Histograms: 2
<span class="o">(</span>Local<span class="o">)</span> workspace index: 0
<span class="o">[</span> 1.  2.  3.  4.  5.  6.  7.<span class="o">]</span>
<span class="o">[</span> 1.  1.  1.  0.  0.  0.<span class="o">]</span>
<span class="o">(</span>Local<span class="o">)</span> workspace index: 1
<span class="o">[</span> 1.  2.  3.  4.  5.  6.  7.<span class="o">]</span>
<span class="o">[</span> 0.  0.  0.  1.  1.  1.<span class="o">]</span>
Histograms: 1
<span class="o">(</span>Local<span class="o">)</span> workspace index: 0
<span class="o">[</span> 1.  2.  3.  4.  5.  6.  7.<span class="o">]</span>
<span class="o">[</span> 0.  1.  1.  1.  0.  0.<span class="o">]</span>
Histograms: 1
<span class="o">(</span>Local<span class="o">)</span> workspace index: 0
<span class="o">[</span> 1.  2.  3.  4.  5.  6.  7.<span class="o">]</span>
<span class="o">[</span> 0.  0.  1.  1.  1.  0.<span class="o">]</span>
</pre></div>
</div>
<p>Output involving the local number of histograms and local indices is obviously not useful for users and should be avoided (see also the section on workspace indices), this example is merely for illustration.</p>
<p>Note that currently Mantid does not support workspaces without spectra, so running above example with more than four MPI ranks fill fail since there are only four spectra.
This is probably not a problem in practice.</p>
</div>
<div class="section" id="logging-output">
<h3><a class="toc-backref" href="#id11">Logging output</a><a class="headerlink" href="#logging-output" title="Permalink to this headline">¶</a></h3>
<p>With many MPI ranks it is common to get spammed by logging output.
Since there is not control of output order for multi-line log messages it also tends to become hard to read since output from different ranks get interleaved.</p>
<p>The current solution to this is a logging offset for all but the master rank.
By default an offset of 1 is added, i.e., an error message from any rank but rank 0 will be displayed as a warning.
The offset can be adjusted in the Mantid properties file, e.g.,</p>
<div class="highlight-sh"><div class="highlight"><pre>mpi.loggingOffset<span class="o">=</span>3
</pre></div>
</div>
<p>The drawback of this approach is that information contained in error or warning messages that are specific to a spectrum, such as a missing detector ID, can be hidden or lost.
If that is an issue the logging offset can simply be set to 0.</p>
</div>
</div>
<div class="section" id="implementing-mpi-support-for-an-algorithm">
<h2><a class="toc-backref" href="#id12">Implementing MPI Support for an Algorithm</a><a class="headerlink" href="#implementing-mpi-support-for-an-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="section" id="supported-workspace-types">
<h3><a class="toc-backref" href="#id13">Supported workspace types</a><a class="headerlink" href="#supported-workspace-types" title="Permalink to this headline">¶</a></h3>
<p>Only <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt> and its subclasses support <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>.
All other workspace types, in particular <tt class="docutils literal"><span class="pre">TableWorkspace</span></tt> and <tt class="docutils literal"><span class="pre">MDWorkspace</span></tt> are restricted to <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt> and <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>.</p>
</div>
<div class="section" id="mechanism">
<h3><a class="toc-backref" href="#id14">Mechanism</a><a class="headerlink" href="#mechanism" title="Permalink to this headline">¶</a></h3>
<p>By default an algorithm does not support MPI and any attempt to execute it in an MPI run will throw an exception.
MPI support for an algorithm is implemented by means of a couple of virtual methods in the <tt class="docutils literal"><span class="pre">Algorithm</span></tt> base class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Algorithm</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execDistributed</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execMasterOnly</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execNonMaster</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">ExecutionMode</span> <span class="n">getParallelExecutionMode</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">StorageMode</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">storageModes</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In general it is <strong>not</strong> necessary to implement all of these methods.
For many algorithms it can be sufficient to implement <tt class="docutils literal"><span class="pre">getParallelExecutionMode</span></tt>.
This is often the case if an algorithm has only a single input and a single output and treats all spectra independently.
In that case the execution mode can simply be determined from the input workspace as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Parallel</span><span class="o">::</span><span class="n">ExecutionMode</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">getParallelExecutionMode</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">StorageMode</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">storageModes</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// The map key is the property name. If there is only one input workspace it can usually be ignored.</span>
  <span class="k">return</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">getCorrespondingExecutionMode</span><span class="p">(</span><span class="n">storageModes</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the helper <tt class="docutils literal"><span class="pre">Parallel::getCorrespondingExecutionMode</span></tt> is used to obtain the &#8216;natural&#8217; execution mode from a storage mode, i.e., <tt class="docutils literal"><span class="pre">ExecutionMode::Identical</span></tt> for <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>, <tt class="docutils literal"><span class="pre">ExecutionMode::Distributed</span></tt> for <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt>, and <tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> for <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>.
More complex algorithms may require more complex decision mechanism, e.g., when there is more than one input workspace.</p>
<p>If none of the other virtual methods listed above is implemented, <tt class="docutils literal"><span class="pre">Algorithm</span></tt> will run the normal <tt class="docutils literal"><span class="pre">exec()</span></tt> method on all MPI ranks.
The exception are non-master ranks if the execution mode is <tt class="docutils literal"><span class="pre">ExecutionMode::MasterOnly</span></tt> &#8211; in that case creating a dummy workspace is attempted.
This is discussed in more detail in the subsections below.</p>
</div>
<div class="section" id="identical-execution">
<h3><a class="toc-backref" href="#id15">Identical execution</a><a class="headerlink" href="#identical-execution" title="Permalink to this headline">¶</a></h3>
<p>Identical execution with execution mode <tt class="docutils literal"><span class="pre">ExecutionMode::Identical</span></tt> is usually done for data with storage mode <tt class="docutils literal"><span class="pre">StorageMode::Cloned</span></tt>.
Execution is handled by simply calling <tt class="docutils literal"><span class="pre">Algorithm::exec()</span></tt> on all MPI ranks.</p>
<p>A notable exception that has to be kept in mind are algorithms that are saving workspaces or write to other resources, since the file names will be in conflict.</p>
</div>
<div class="section" id="distributed-execution">
<h3><a class="toc-backref" href="#id16">Distributed execution</a><a class="headerlink" href="#distributed-execution" title="Permalink to this headline">¶</a></h3>
<p>Distributed execution is handled by <tt class="docutils literal"><span class="pre">Algorithm::execDistributed()</span></tt>.
By default this simply calls <tt class="docutils literal"><span class="pre">Algorithm::exec()</span></tt>.
In many cases this may be perfectly fine and more convenient than reimplementing <tt class="docutils literal"><span class="pre">Algorithm::execDistributed()</span></tt>.</p>
<p>The following example illustrates the difference.
We can either check for the number of MPI ranks in the normal <tt class="docutils literal"><span class="pre">exec()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">exec</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//// Algorithm logics, e.g., a sum over all spectra ////</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">communicator</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//// MPI calls, e.g., a global sum ////</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, we can implement <tt class="docutils literal"><span class="pre">Algorithm::execDistributed()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">exec</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//// Algorithm logics ////</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">execDistributed</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//// Algorithm logics but in a very different way ////</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Many algorithms in Mantid will require very little modification for MPI support and thus the first option is likely to be the first choice.</p>
</div>
<div class="section" id="master-only-execution">
<h3><a class="toc-backref" href="#id17">Master-only execution</a><a class="headerlink" href="#master-only-execution" title="Permalink to this headline">¶</a></h3>
<p>Master-only execution is handled by <tt class="docutils literal"><span class="pre">Algorithm::execMasterOnly()</span></tt>.
By default this simply calls <tt class="docutils literal"><span class="pre">Algorithm::exec()</span></tt> on rank 0 and <tt class="docutils literal"><span class="pre">Algorithm::execNonMaster()</span></tt> on all other ranks.</p>
<p>To support running existing Python scripts without significant modification, and to be able to automatically determine execution modes based on input workspaces, workspaces with storage mode <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt> also exist on the non-master ranks.
The default implementation of <tt class="docutils literal"><span class="pre">Algorithm::execNonMaster()</span></tt> creates an <strong>uninitialized</strong> (in the case of <tt class="docutils literal"><span class="pre">MatrixWorkspace</span></tt>) workspace of the same type as the input workspace.
If <tt class="docutils literal"><span class="pre">Algorithm::execNonMaster()</span></tt> is overridden, any workspaces that are created shall also be uninitialized and should have storage mode <tt class="docutils literal"><span class="pre">StorageMode::MasterOnly</span></tt>.</p>
<p>Given that the workspace on non-master ranks are not initialized, no methods of the workspace should be called, apart from <tt class="docutils literal"><span class="pre">Workspace::storageMode()</span></tt>.
Validators on the non-master ranks are thus also disabled.</p>
<p>A typical implementation could look as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">execNonMaster</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;OutputWorkspace&quot;</span><span class="p">,</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Workspace2D</span><span class="o">&gt;</span><span class="p">(</span>
                                     <span class="n">Parallel</span><span class="o">::</span><span class="n">StorageMode</span><span class="o">::</span><span class="n">MasterOnly</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-spectrum-numbers">
<h3><a class="toc-backref" href="#id18">Setting spectrum numbers</a><a class="headerlink" href="#setting-spectrum-numbers" title="Permalink to this headline">¶</a></h3>
<p>Setting spectrum numbers via the legacy interface <tt class="docutils literal"><span class="pre">MatrixWorkspace::getSpectrum(size_t)::setSpectrumNo(specnum_t)</span></tt> is not supported in MPI runs and will throw an exception.
The reason is that spectrum numbers are used to globally identify a spectrum and thus changing a spectrum number must be done globally, i.e., on all MPI ranks.
Spectrum numbers should be set by using <tt class="docutils literal"><span class="pre">Indexing::IndexInfo</span></tt> and <tt class="docutils literal"><span class="pre">MatrixWorkspace::setIndexInfo()</span></tt>, or rather by passing the <tt class="docutils literal"><span class="pre">IndexInfo</span></tt> to one of the workspace factory functions from <tt class="docutils literal"><span class="pre">DataObjects/WorkspaceCreation.h</span></tt>.</p>
</div>
<div class="section" id="workspace-indices">
<h3><a class="toc-backref" href="#id19">Workspace indices</a><a class="headerlink" href="#workspace-indices" title="Permalink to this headline">¶</a></h3>
<p>If a workspace is distributed, i.e., has storage mode <tt class="docutils literal"><span class="pre">StorageMode::Distributed</span></tt> workspaces indices lose their meaning.
In particular, <tt class="docutils literal"><span class="pre">MatrixWorkspace::getNumberHistograms()</span></tt> will return the local number of spectra and not the global size of the workspace.
For purposes of interaction with the user interface and for internal consistency a global equivalent of the &#8216;workspace index&#8217; concept has been introduced.
This index is represented by <tt class="docutils literal"><span class="pre">Indexing::GlobalSpectrumIndex</span></tt>. <a class="footnote-reference" href="#spectrum-index" id="id2">[2]</a></p>
<p>The consequences are as follows:</p>
<ul class="simple">
<li>Workspace indices should not be logged or written into output of other types such as tables. Instead spectrum numbers (<tt class="docutils literal"><span class="pre">Indexing::SpectrumNumber</span></tt>) or global spectrum indices (<tt class="docutils literal"><span class="pre">Indexing::GlobalSpectrumIndex</span></tt>) must be used.</li>
<li>The number of histograms in a workspace obtained from <tt class="docutils literal"><span class="pre">MatrixWorkspace::getNumberHistograms()</span></tt> may only be used for processing all spectra, i.e., when each MPI rank is processing all its local spectra.
It should not be logged, written as output, or used for branching execution paths since it is meaningless.
If the total number of spectra in a workspace is required it can be accessed via <tt class="docutils literal"><span class="pre">MatrixWorkspace::indexInfo()::globalSize()</span></tt>.</li>
<li>User input providing indices or spectrum numbers in way or another must be translated into local indices by <tt class="docutils literal"><span class="pre">IndexInfo</span></tt>.
The most common cases will be covered by a workspace property that also accepts indices (under development).</li>
<li>The distinction between local and global indices must not be exposed to the user.
In particular, the &#8216;global&#8217; prefix should be omitted, i.e., for the user interface we keep referring to &#8216;workspace index&#8217;, even though it is internally not what used to be the workspace index but rather a global index.</li>
</ul>
</div>
<div class="section" id="instrument-and-detectors">
<h3><a class="toc-backref" href="#id20">Instrument and detectors</a><a class="headerlink" href="#instrument-and-detectors" title="Permalink to this headline">¶</a></h3>
<p>As described above, the full set of detectors is held on each MPI rank.
Thus, algorithms that modify detectors must do so <strong>in an identical</strong> manner on all MPI ranks.
That is, if for example detector positions would be modified in an Algorithm it is <strong>not</strong> sufficient to do so for all detectors that have a corresponding spectrum on the MPI rank.
Instead such a modification must be done for all detectors.</p>
<p>The details of this depend on what exactly an algorithm is supposed to do and a generic recipe cannot be given here.
It is however essential to think of this when providing MPI support for an algorithm.</p>
</div>
<div class="section" id="gui">
<h3><a class="toc-backref" href="#id21">GUI</a><a class="headerlink" href="#gui" title="Permalink to this headline">¶</a></h3>
<p>Running the Mantid GUI with MPI support, such as a client GUI with a MPI-based backend, is currently not possible.
If it cannot be avoided to add an MPI-related property to an algorithm is shall be made invisible in the GUI.
This can be done by adjusting the property settings when implementing <tt class="docutils literal"><span class="pre">Algorithm::init()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;MantidKernel/InvisibleProperty.h&quot;</span>

<span class="kt">void</span> <span class="n">MyAlg</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">setPropertySettings</span><span class="p">(</span><span class="s">&quot;MyProperty&quot;</span><span class="p">,</span> <span class="n">Kernel</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">InvisibleProperty</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="units-tests">
<h3><a class="toc-backref" href="#id22">Units Tests</a><a class="headerlink" href="#units-tests" title="Permalink to this headline">¶</a></h3>
<p>For unit testing the MPI support of an algorithm a fake backend that can be run without MPI is provided.
No modifications to the code under test a required.
In the unit test case <tt class="docutils literal"><span class="pre">ParallelRunner</span></tt> from <tt class="docutils literal"><span class="pre">MantidTestHelpers</span></tt> is used to run the algorithm (or other code) under test as if it were part of on MPI run.
A typical example could look as follows:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &quot;MantidTestHelpers/ParallelAlgorithmCreation.h&quot;</span>
<span class="cp">#include &quot;MantidTestHelpers/ParallelRunner.h&quot;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">run_algorithm</span><span class="p">(</span><span class="k">const</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">Communicator</span> <span class="o">&amp;</span><span class="n">comm</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">MyType1</span> <span class="o">&amp;</span><span class="n">arbitrary</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyType2</span> <span class="o">&amp;</span><span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Creating the algorithm with this helper function is the recommended way,</span>
  <span class="c1">// otherwise the communicator has to be set by hand and the name of the</span>
  <span class="c1">// output workspace must be set to a different value depending on comm.rank()</span>
  <span class="c1">// to avoid clashes, since the threading backend in ParallelRunner shares the</span>
  <span class="c1">// ADS for all &#39;ranks&#39;.</span>
  <span class="k">auto</span> <span class="n">alg</span> <span class="o">=</span> <span class="n">ParallelTestHelpers</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">Mantid</span><span class="o">::</span><span class="n">Algorithms</span><span class="o">::</span><span class="n">MyAlg</span><span class="o">&gt;</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>
  <span class="n">alg</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;InputWorkspace&quot;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">WorkspaceTester</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="n">alg</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
  <span class="n">Workspace_const_sptr</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">alg</span><span class="o">-&gt;</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;OutputWorkspace&quot;</span><span class="p">);</span>
  <span class="n">TS_ASSERT_EQUALS</span><span class="p">(</span><span class="n">ws</span><span class="o">-&gt;</span><span class="n">storageMode</span><span class="p">(),</span> <span class="n">Parallel</span><span class="o">::</span><span class="n">StorageMode</span><span class="o">::</span><span class="n">Distributed</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyAlgTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CxxTest</span><span class="o">::</span><span class="n">TestSuite</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// ...</span>

  <span class="kt">void</span> <span class="n">test_parallel</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Runs run_algorithm in multiple threads. The first argument passed to</span>
    <span class="c1">// run_algorithm is of type Parallel::Communicator and is guaranteed to</span>
    <span class="c1">// have size() &gt; 1, i.e., more than one rank, in at least one call to</span>
    <span class="c1">// run_algorithm (it is in addition also called with a single &#39;rank&#39;).</span>
    <span class="n">ParallelTestHelpers</span><span class="o">::</span><span class="n">runParallel</span><span class="p">(</span><span class="n">run_algorithm</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mf">42.0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Here <tt class="docutils literal"><span class="pre">MantidTestHelpers/ParallelAlgorithmCreation.h</span></tt> provides the algorithm factory method <tt class="docutils literal"><span class="pre">ParallelTestHelpers::create&lt;WorkspaceType&gt;</span></tt>.
<tt class="docutils literal"><span class="pre">MantidTestHelpers/ParallelRunner.h</span></tt> provides <tt class="docutils literal"><span class="pre">ParallelTestHelpers::runParallel</span></tt>, which uses <tt class="docutils literal"><span class="pre">ParallelRunner</span></tt> with a reasonable default choice for the number of ranks.</p>
</div>
<div class="section" id="documentation">
<h3><a class="toc-backref" href="#id23">Documentation</a><a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h3>
<p>When adding MPI support for an algorithm, add it to the table at the end of this document.
Potential limitations must be described in the comments.</p>
</div>
</div>
<div class="section" id="supported-algorithms">
<h2><a class="toc-backref" href="#id24">Supported Algorithms</a><a class="headerlink" href="#supported-algorithms" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="19%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Algorithm</th>
<th class="head">Supported modes</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CreateWorkspace</td>
<td>all</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Rebin</td>
<td>all</td>
<td>min and max bin boundaries must be given explicitly</td>
</tr>
</tbody>
</table>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="split-instrument" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The complexity and overhead of splitting the instrument, in particular given the overhead ensuing from handling all cases exemplified above, led to the decision split only the neutron data based on spectra, but not detectors.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="spectrum-index" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Some will argue that this should be <tt class="docutils literal"><span class="pre">GlobalWorkspaceIndex</span></tt>.
However it is not an index of a workspace so the term <tt class="docutils literal"><span class="pre">GlobalSpectrumIndex</span></tt> has been chosen for clarity.
On the user interface side this will still be named &#8216;workspace index&#8217;, dropping the &#8216;global&#8217; since the distinction between global and local indices is irrelevant for users.</td></tr>
</tbody>
</table>
<p><strong>Category</strong>: <a class="reference external" href="categories/Development.html">Development</a></p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="index.html" title="Previous Chapter: Development"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Development</span>
    </a>
  </li>
  <li>
    <a href="ISISSANSReductionBackend.html" title="Next Chapter: ISIS SANS Reduction Back-end"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">ISIS SANS Reduct... &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>